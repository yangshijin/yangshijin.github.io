[{"title":"基于python3.x+opencv3的hsv颜色+轮廓法车牌粗定位","date":"2017-04-15T07:45:39.000Z","path":"2017/04/15/基于python3-x-opencv3的hsv颜色-轮廓法车牌粗定位/","text":"前言 上一篇文章将了基于图像学sobel算子等图像处理的边缘检测法通过轮廓检测进行车牌粗定位，结尾也说了，这种方法有可能出现错误定位，或者定位出多个区域，今天我们来试试通过将图片转换成hsv模式，看看是否能通过色调区域方法找到车牌区域，从而完成车牌粗定位。 1.加载图片，转换成hsv模式 HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。这个模型中颜色的参数分别是：色调（H），饱和度（S），明度（V）。 对图形图像学没有太多了解的朋友可能比较少听过HSV模型，更多听到的是RGB模型，或者RGBA模型，和RGB模型这种三维坐标的颜色模型不同的是，HSV模型，是针对用户观感的一种颜色模型，侧重于色彩表示，什么颜色、深浅如何、明暗如何。H是色彩，S是深浅， S = 0时，只有灰度，V是明暗，表示色彩的明亮程度，但与光强无直接联系。 opencv提供了这样一个方法，可以直接将rgb模式的图片转换成hsv模式的图片，方法为cv2.cvtColor(img, cv2.COLOR_BGR2HSV),也就是转换成灰度图的方法，只是参数不一样。 2. 定义车牌的hsv区间 这里不对HSV模型进行深入讲解，有兴趣的同学可以直接google一下，资料很多，这里我们只需要找到车牌的hsv颜色区间，假设只对蓝底白字车牌进行定位，那么颜色空间就是：H区间：[100,140] , S区间：[50,255] , V区间：[50,255] ，S和V之所以跨度这么大，是因为不同的时间、光照、摄像机拍出来的效果值可能差距会比较大。 3.找到图中包含这个hsv区间的所有像素 遍历经过转换成hsv模式图片的所有像素点，将所有处于这个颜色区间的像素点标识出来，置为1（255）,不处于这个颜色区间的像素点置为0,从而形成了一张二值化的图片。 opencv提供了这样的一个方法，因此我们不需要手动编码去遍历图片的所有像素，方法为：cv2.inRange(hsv_img, lower_color, higher_color).第一个参数为hsv模式的图片，第二个参数为颜色区间的最低值，第三个参数为颜色区间的最大值。效果如下： 4.矩形链接、噪点处理 由步骤三得到的二值化图可知，绝大部分图片具有蓝色区间的区域不仅仅是在车牌处，其他的地方也有可能具有这个颜色的像素点，甚至蓝色的标识牌、蓝色的车身会极大的干扰到车牌的定位。 由于车牌字体肯定不属于蓝色区间，这里我们首先要做的就是将蓝色的车牌矩形处中间由于车牌号而镂空的地方链接起来，因此首先进行一轮闭操作，闭操作原理上一篇文章有讲过。效果如下： 可以看到车牌区域中间镂空的预期已经补齐，接下来去除细小噪点，原理同样在上一篇文章有讲过，即开操作，先对图片进行腐蚀，再进膨胀，去除掉细小的像素点。效果如下： 5.进行边缘检测，寻找图中所有矩形 对二值化图像进行链接、去燥处理后，图片已经很干净，这里直接用上一篇文章用到的形态学方法，寻找图中矩形，然后进行过滤判断，最终定位到车牌区域，效果如下： PS：同样的，这里只是粗定位，而且是只针对蓝底车牌的粗定位，像其他黄底、黑底、白底的车牌，在这里没有任何可能定位出来，另外，即使是蓝底车牌还是有可能定位到多个矩形区域，或者干脆定位不到车牌区域，因此，要保持较高的识别率，仅仅使用hsv模式定位是不行的，可能通过结合上一篇文章讲到的边缘检测的识别方法，来对车牌进行一个定位，这样能保持比较高的识别率。 6.实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import cv2import numpy as np# 定义蓝底车牌的hsv颜色区间lower_blue = np.array([100, 50, 50])higher_blue = np.array([140, 255, 255])# 找到符合车牌形状的矩形def findPlateNumberRegion(img): region = [] # 查找外框轮廓 contours_img, contours, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) print(\"contours lenth is :%s\" % (len(contours))) # 筛选面积小的 for i in range(len(contours)): cnt = contours[i] # 计算轮廓面积 area = cv2.contourArea(cnt) # 面积小的忽略 if area &lt; 2000: continue # 转换成对应的矩形（最小） rect = cv2.minAreaRect(cnt) # print(\"rect is:%s\" % &#123;rect&#125;) # 根据矩形转成box类型，并int化 box = np.int32(cv2.boxPoints(rect)) # 计算高和宽 height = abs(box[0][1] - box[2][1]) width = abs(box[0][0] - box[2][0]) # 正常情况车牌长高比在2.7-5之间,那种两行的有可能小于2.5，这里不考虑 ratio = float(width) / float(height) if ratio &gt; maxPlateRatio or ratio &lt; minPlateRatio: continue # 符合条件，加入到轮廓集合 region.append(box) return regionif __name__ == '__main__': img = cv2.imread(\"d:\\\\carImage\\\\car_02.jpg\") # 转换成hsv模式图片 hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # 找到hsv图片下的所有符合蓝底颜色区间的像素点，转换成二值化图像 in_range_array = cv2.inRange(hsv_img, lower_blue, higher_blue) # 进行闭操作，链接车牌区域 element = cv2.getStructuringElement(cv2.MORPH_RECT, (17, 3)) closed = cv2.morphologyEx(in_range_array, cv2.MORPH_CLOSE, element) # 进行开操作，去除细小噪点 eroded = cv2.erode(closed, None, iterations=2) dilation = cv2.dilate(eroded, None, iterations=2) # 查找并筛选符合条件的矩形区域 region = findPlateNumberRegion(dilation) # 标识出所有符合条件的矩形区域 if len(region) != 0: for i in range(len(region)): box = region[i] rect_img = findRectImg(box, tmp_img) rect_imgs.append(rect_img) cv2.drawContours(img, [box], 0, (0, 255, 0), 1) cv2.imshow(\"img\", img)","tags":[{"name":"python","slug":"python","permalink":"http://qgxiaojin.com/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://qgxiaojin.com/tags/opencv/"},{"name":"车牌识别","slug":"车牌识别","permalink":"http://qgxiaojin.com/tags/车牌识别/"},{"name":"机器学习","slug":"机器学习","permalink":"http://qgxiaojin.com/tags/机器学习/"}]},{"title":"基于python3.x + opencv3的图像学轮廓方法车牌粗定位","date":"2017-04-11T14:22:59.000Z","path":"2017/04/11/基于python3-x-opencv3的图像学轮廓方法车牌粗定位/","text":"前言 最近准备迈入机器学习的大门，有经验的同事推荐我先从简单的小项目做起，于是乎他推荐了车牌识别的项目，然后就开始了相关的研究，车牌首先是从一个大图中先定位出来，然后才能识别其中的车牌号码，车牌怎么从一张大的图片就定位出来呢，看了基于c++的开源项目easyPR的作者博客，按着他的思路，可以先从图像学的角度来定位车牌。 环境准备 由于在选型的时候，选了最近很火的谷歌的开源深度学习框架“TensorFlow”,又由于本人是苦逼的windows党，TensorFlow目前最新的版本，需要制定python版本3.5，于是第一个需要安装的就是python3.5啦。 另外一个就是基于python安装的opencv3 定位思路（基于轮廓定位）1.图片灰度化（将三元色的图片转换为只有一个灰度通道的图片，处理起来更容易）2.图片高斯模糊（去除干扰的噪声，easyPR的作者思路是先高斯模糊再灰度化）3.Sobel算子处理4.图像二值化5.闭操作6.腐蚀-&gt;膨胀7.取轮廓列表8.基于车牌形状特性筛选上面七个步骤大致就是我初步实现的思路，借鉴了easyPR的作者的前部分思路，当然这只是粗定位，后面还需要很多需要优化，但作为初学者，第一步肯定是先从简单的来实现啦。 1. 图片灰度化 这一步使用python+opencv实现起来非常简单，有两种方法，第一种是加载图片的时候加一个参数，直接灰度化，第二种是加载后另外调用opencv的API-&gt;cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)来进行灰度化，居然方法细节可以直接看方法定义 2. 高斯模糊 高斯模糊，也称高斯平滑，根据高斯曲线调节像素色值，它是有选择地模糊图像。说得直白一点，就是高斯模糊能够把某一点周围的像素色值按高斯曲线统计起来，采用数学上加权平均的计算方法得到这条曲线的色值，最后能够留下人物的轮廓，即曲线．具体的原理介绍各位可以自己google一下。 opencv也提供了高斯模糊的API-&gt;cv2.GaussianBlur(),具体参数含义可以看一看API手册，这里只讲第二个参数，即模糊范围，这个范围分为x、y方向，我选择了3-3作为模糊的计算范围。 3. sobel算子处理 sobel算子是一种图像处理算法，主要用作边缘检测.车牌的特征非常适合用sobel算子来做处理，通过sobel算子能清晰的识别出车牌的边缘，字母的边缘，得出的灰度图如下所示： 4. 二值化 二值化的原理很简单，就是对一张灰度图像，基于某个阈值，当大于这个阈值的时候，置为1，小于这个阈值的时候置为0，比如我设置一个阈值为150，那么当这张灰度图的图片的某个像素点的值为170，那么二值化操作后的值就是1，也就是颜色通道的最大值255。为什么要进行二值化呢，和灰度化一样，进一步简化图像的表达，让之后的形态学图像处理更加简单。二值化后的图像如下： 5. 闭操作 要了解闭操作，首先要了解图像学的腐蚀、膨胀，什么是图像的膨胀处理呢？通俗点来讲，就是有一个二维的矩阵定义，比如3*3,然后对一个图像进行像素点遍历，基于每一个像素点作为矩阵中心点，然后对这个像素点的周边被矩阵包含的像素点做一个局部最大值的替换，腐蚀操作则反之，取局部最小值。 那么闭操作的原理其实就是对图像先进行膨胀操作，再进行腐蚀操作，这样有什么作用呢，相信大家也看到二值化后的图像，车牌的字符边缘很清晰的展现出来，但是我们这是要根据车牌轮廓来做粗定位的，那么我们要让车牌区域变成一个白色的矩形，闭操作第一步的膨胀操作，将车牌字符与字符之间的空白连接起来，想成一个基于车牌区域往外扩展一点的矩形区域，第二步闭操作，将由于膨胀操作使得车牌矩形往外扩展的区域腐蚀掉。 这个时候需要讲一下，这里的闭操作的参数之一，闭操作的像素范围，即进行局部极值计算的二维矩阵定义，由于车牌的特性，我们定义的矩阵最好是按照车牌的长宽比例来进行处理，大约是2.5-5.5这个比例内的参数调优，我自己试了一下，4左右的比例应该效果是最好的，另外就是范围的大小，由于要定位的图片不一，因此最好是根据你当前的图片库的平均大小来做确定，我自己网上找图片试了一下，大致是20左右的x像素点，4-5左右的y像素点。处理结果如下： 6. 腐蚀-&gt;膨胀 细心的朋友应该发现了，上面闭操作之后的图片，还是有一些小的白点细长的白点存留，这些俗称为噪点，也就是干扰项，这个时候需要进行腐蚀操作，将细小的点给腐蚀掉，然后腐蚀掉肯定车牌区域的大小会受影响，因此后面要膨胀处理，来补偿因为处理掉细节而腐蚀掉的区域。其实腐蚀操作也就是开操作，这个操作一般也就是用来处理掉细小的噪点的。那这里我为什么要分开呢，因为要进行车牌定位的图片的噪点往往进行一轮腐蚀没办法完全腐蚀掉，而闭操作只是进行一轮腐蚀后就进行膨胀了，这样没有完全腐蚀掉的细节又重新膨胀回来了。因此分开操作，opencv的腐蚀、膨胀方法，有个参数可以定义进行几轮处理，因此这里可以根据图片的情况，具体调优。调优后的图片如下： 7. 取轮廓列表 找轮廓列表其实就是讲上面处理后的二值化图像的白色部分筛选出来，opencv有现成的API，cv2. cv2.findContours() 8. 筛选 找到所有的轮廓之后，就要基于车牌的特性进行筛选了，首先将轮廓转为一个矩形，然后将面积小的过滤掉，然后根据车牌的形态特性，即长宽比例筛选出正确的车牌矩形，当然，这里有可能筛选不到任何的矩形，也有可能筛选到多个矩形出来。比如本图的例子图片，就筛选出了两个矩形出来，如下(我用绿色的线画出来了)： 这里的只是初步将车牌区域定位出来，甚至可能定位出多个不是车牌的区域，后面需要继续优化。 实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import cv2import numpy as npminPlateRatio = 2.5 # 车牌最小比例maxPlateRatio = 5 # 车牌最大比例# 图像处理def imageProcess(gray): # 高斯平滑 gaussian = cv2.GaussianBlur(gray, (3, 3), 0, 0, cv2.BORDER_DEFAULT) # Sobel算子，X方向求梯度 sobel = cv2.convertScaleAbs(cv2.Sobel(gaussian, cv2.CV_16S, 1, 0, ksize=3)) # 二值化 ret, binary = cv2.threshold(sobel, 150, 255, cv2.THRESH_BINARY) # 对二值化后的图像进行闭操作 element = cv2.getStructuringElement(cv2.MORPH_RECT, (18, 4)) closed = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, element) # 再通过腐蚀-&gt;膨胀 去掉比较小的噪点 erosion = cv2.erode(closed, None, iterations=2) dilation = cv2.dilate(erosion, None, iterations=2) # 返回最终图像 return dilation# 找到符合车牌形状的矩形def findPlateNumberRegion(img): region = [] # 查找外框轮廓 contours_img, contours, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) print(\"contours lenth is :%s\" % (len(contours))) # 筛选面积小的 for i in range(len(contours)): cnt = contours[i] # 计算轮廓面积 area = cv2.contourArea(cnt) # 面积小的忽略 if area &lt; 2000: continue # 转换成对应的矩形（最小） rect = cv2.minAreaRect(cnt) # print(\"rect is:%s\" % &#123;rect&#125;) # 根据矩形转成box类型，并int化 box = np.int32(cv2.boxPoints(rect)) # 计算高和宽 height = abs(box[0][1] - box[2][1]) width = abs(box[0][0] - box[2][0]) # 正常情况车牌长高比在2.7-5之间,那种两行的有可能小于2.5，这里不考虑 ratio = float(width) / float(height) if ratio &gt; maxPlateRatio or ratio &lt; minPlateRatio: continue # 符合条件，加入到轮廓集合 region.append(box) return regiondef detect(img): # 转化成灰度图 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 形态学变换的处理 dilation = imageProcess(gray) # 查找车牌区域 region = findPlateNumberRegion(dilation) # 默认取第一个 box = region[0] #在原图画出轮廓 cv2.drawContours(img, [box], 0, (0, 255, 0), 2) # 找出box四个角的x点，y点，构成数组并排序 ys = [box[0, 1], box[1, 1], box[2, 1], box[3, 1]] xs = [box[0, 0], box[1, 0], box[2, 0], box[3, 0]] ys_sorted_index = np.argsort(ys) xs_sorted_index = np.argsort(xs) # 取最小的x，y 和最大的x，y 构成切割矩形对角线 min_x = box[xs_sorted_index[0], 0] max_x = box[xs_sorted_index[3], 0] min_y = box[ys_sorted_index[0], 1] max_y = box[ys_sorted_index[3], 1] # 切割图片，其实就是取图片二维数组的在x、y维度上的最小minX,minY 到最大maxX,maxY区间的子数组 img_plate = img[min_y:max_y, min_x:max_x] return img_plateif __name__ == '__main__': imagePath = 'd:\\\\CarImage\\\\car_04.jpg' # 图片路径 img = cv2.imread(imagePath) img = detect(img) cv2.imshow(\"img\",img) cv2.waitKey(0)","tags":[{"name":"python","slug":"python","permalink":"http://qgxiaojin.com/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://qgxiaojin.com/tags/opencv/"},{"name":"车牌识别","slug":"车牌识别","permalink":"http://qgxiaojin.com/tags/车牌识别/"},{"name":"机器学习","slug":"机器学习","permalink":"http://qgxiaojin.com/tags/机器学习/"}]},{"title":"设计杂谈:一种链式生命周期管理设计","date":"2017-04-06T14:16:19.000Z","path":"2017/04/06/设计杂谈-一种链式生命周期管理设计/","text":"最近在了解大数据及机器学习相关的技术，在看到一张关于hadoop的hdfs的写数据过程的流程图之后，发现hdfs在分布式集群上写数据的过程设计，和我之前设计的一个流程引擎的一个流程生命周期有很大的相似之处，因此今天拿出来分享一下。 先来看看hdfs在分布式是怎么写数据的： 这里不讲hadoop的相关技术，忽略其他细节，大致就是由集群的master（名称节点）开始一个写数据的流程，由这个节点决定这个数据要往哪些机器上写，分别写什么部分，但是这个master并不是分成多份数据直接发送到不同的机器上，执行写数据的命令。而是进行流式写入，先将数据发送到第一台机器，第一台机器写完之后由第一台机器发往第二台机器，依次类推，知道最后一台机器将数据写完，又进行节点回调，告诉倒数第二台机器数据写完，倒数第二台收到后，告诉倒数第三台机器数据写完的消息，依次回调到master主机上。 在hdfs的设计理念上，这样的做法确实是最合适的，因为所有的数据请求都需要通过名称节点（master）来处理，如果这样的分布式数据存储消息都要由master来处理的话，随着集群规模的扩大，数据请求数量变得庞大，master节点必然处理起来会非常乏力，可能出现cpu爆满，甚至宕机的情况。这样做的坏处也是有的，最明显的就是花费了更多的网络带宽（当然一般集群都是局域网的），因此这样也无伤大雅。 那么说完这个之后，先来看看我之前的基础设计是怎样的： 这个设计其实很简单，Step接口定义了两个接口，分别是stepBegin()和stepEnd()，分别来处理流程节点事务和流程结束的回调处理，整个流程的生命周期由代理类StepNode来管理，StepNode有聚合实现了Step接口的具体流程节点类，并确定好节点之间的次序关系。如下图： 图中的1、2、3、4步骤代表四个流程节点的事务处理操作，即stepBegin(),图中的5、6、7、8步骤代表流程结束后各个节点的回调处理操作，即stepEnd()。 这样设计的好处是：整个流程的生命周期都在可控的范围之内，非常容易管理到每一个节点，并且每个节点都能清楚的知道其所依赖的前后节点的执行状况，并且通过上下文参数来传递可用的信息，同时流程节点也十分容易扩展，可扩展的面非常广，应用的面也非常。 PS:当然，具体的项目应用肯定不仅仅是上面的类图设计的那么简单，但是思想是一样的，设计的理念是一样的，只是不同的应用实现可以做不同的扩展、优化。 PS2：一个好的设计来源于适合的应用场景，有一个很著名的话是这样讲的： 美不是来自于创造，没来自于选择。 我对这句话在程序员的角度理解： 好的设计不是来自于遐想，来自于选择对的应用场景。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"杂谈","slug":"杂谈","permalink":"http://qgxiaojin.com/tags/杂谈/"}]},{"title":"myBatis中的Spring技术探究：SqlSessionFacotry之InitializingBean（Spring容器加载bean过程中的钩子简析）","date":"2017-03-30T13:12:36.000Z","path":"2017/03/30/myBatis中的Spring技术探究：SqlSessionFacotry之InitializingBean（Spring容器加载bean过程中的钩子简析）/","text":"这个系列的上一篇文章讲了SqlSessionFacotry的FacotryBean工厂类，并留下了已给伏笔，在SqlSessionFacotryBean的getObject()方法中调用了afterPropertiesSet()方法，这个方法其实也是Spring技术的一个钩子方法，也就是本篇文章的主体类：InitializingBean接口定义的钩子（回调）方法，先来看看类定义代码及注释： 123456789101112131415161718192021222324252627282930/** * Interface to be implemented by beans that need to react once all their * properties have been set by a BeanFactory: for example, to perform custom * initialization, or merely to check that all mandatory properties have been set. * * &lt;p&gt;An alternative to implementing InitializingBean is specifying a custom * init-method, for example in an XML bean definition. * For a list of all bean lifecycle methods, see the BeanFactory javadocs. * * @author Rod Johnson * @see BeanNameAware * @see BeanFactoryAware * @see BeanFactory * @see org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName * @see org.springframework.context.ApplicationContextAware */public interface InitializingBean &#123; /** * Invoked by a BeanFactory after it has set all bean properties supplied * (and satisfied BeanFactoryAware and ApplicationContextAware). * &lt;p&gt;This method allows the bean instance to perform initialization only * possible when all bean properties have been set and to throw an * exception in the event of misconfiguration. * @throws Exception in the event of misconfiguration (such * as failure to set an essential property) or if initialization fails. */ void afterPropertiesSet() throws Exception;&#125; 从注释文档可以得知，实现这个接口的类一般目的是为了在Spring容器加载bean并将所有属性(其实就是bean的成员变量)都设置好之后，回调这个方法来做一个check，当然，方法的注释也说了，当检查发现错误配置的时候，这个方法也可以用来初始化正确的配置属性。 另外，从注释中野了解到了相关的一些类，包括BeanFactoryAware、ApplicationContextAware、BeanNameAware系列接口，以及上一次讲获取bean的时候用来处理FacotryBean这个工厂类的主角：BeanFactory，这一次同样的，从InitializingBean的注释文档，很容易猜出，这是在加载Bean的时候会做的回调操作，那么直接看BeanFactory的默认实现有没有类似加载、创建Bean的方法，首先查看了一下AbstractBeanFactory这个抽象类，发现有一个抽象方法是CreateBean()方法，没有具体实现，由于我使用的是强大的IntelliJ Idea,所以直接搜索这个方法的具体实现有哪些，发现AbstractAutowireCapableBeanFactory这个类继承并实现了它，虽然这个类也是一个抽象类，但是这里已经实现了createBean()方法，因此我们直接看它的代码就好： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196/** * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); &#125; RootBeanDefinition mbdToUse = mbd; // 根据bean名称处理一下bean的Class,此处不细讲 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // 校验和准备bean重载的方法，不细讲，有兴趣可以看看，虽然没什么好看的。。 try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); &#125; //真正创建bean的方法 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); &#125; return beanInstance;&#125;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; BeanWrapper instanceWrapper = null; //如果是单例，先从实例缓存获取bean，若不存在，实例化一个bean if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); //允许实现了MergedBeanDefinitionPostProcessor接口的bean去指定bean的定义，这里也就会调用接口的postProcessMergedBeanDefinition()钩子方法 synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125; //如果是单例，为单例bean增加一个单例工厂来构建指定的bean boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // 实例化bean Object exposedObject = bean; try &#123; //填充bean populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; //真正实例化bean，我们要关注的重点方法！ exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); &#125; &#125; //如果是earlySingletonExposure为真，做相关的bean处理及依赖校验处理 if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); &#125; return exposedObject; &#125; /** * Initialize the given bean instance, applying factory callbacks * as well as init methods and bean post processors. * &lt;p&gt;Called from &#123;@link #createBean&#125; for traditionally defined beans, * and from &#123;@link #initializeBean&#125; for existing bean instances. * @param beanName the bean name in the factory (for debugging purposes) * @param bean the new bean instance we may need to initialize * @param mbd the bean definition that the bean was created with * (can also be &#123;@code null&#125;, if given an existing bean instance) * @return the initialized bean instance (potentially wrapped) * @see BeanNameAware * @see BeanClassLoaderAware * @see BeanFactoryAware * @see #applyBeanPostProcessorsBeforeInitialization * @see #invokeInitMethods * @see #applyBeanPostProcessorsAfterInitialization */ protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; //1.调用XXXAware接口系列钩子方法，后面会讲 if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; //2、调用PostProcessors系列接口的beforePost方法，后面会讲 Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //3.调用初始化方法，InitializingBean的钩子方法就在此处调用 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); &#125; //4.调用PostProcessors系列接口的afterPost方法， if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; 通过阅读代码，忽略一些无关紧要的校验、日志、扩展配置处理的代码之后，发现真正在bean的生命周期中调用的钩子方法都在initializeBean()方法中，有4处调用钩子的方法，接下来我们一个一个来讲。 第一个是invokeAwareMethods()方法，这个方法会调用bean所实现的所有实现了Aware接口的接口，先看看代码： 12345678910111213private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; (BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 在抽象类型默认实现了3中Aware系列接口的钩子回调，分别是BeanNameAware、BeanClassLoaderAware、BeanFacotryAware，直接查看Aware接口的注释文档，可以知道，所有实现了Aware的接口需要定义一个返回void，且只有一个入参的方法，这个入参可以在容器创建bean定义的时候以钩子调用形式传入，在方法内使用。比如上述默认实现的代码中，三个接口分别要求容器传入bean名称、类的加载器、bean工厂，一般bean实现之后，直接引用给类成员变量，供类的其他方法使用。 第二个方法是applyBeanPostProcessorsBeforeInitialization()方法，直接看实现： 12345678910111213@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 这里直接获取了所有的BeanPostProcessors，然后调用postProcessBeforeInitialization()方法，那么BeanPostProcessor类是做什么的呢？来看看定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Factory hook that allows for custom modification of new bean instances, * e.g. checking for marker interfaces or wrapping them with proxies. * * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their * bean definitions and apply them to any beans subsequently created. * Plain bean factories allow for programmatic registration of post-processors, * applying to all beans created through this factory. * * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces * or the like will implement &#123;@link #postProcessBeforeInitialization&#125;, * while post-processors that wrap beans with proxies will normally * implement &#123;@link #postProcessAfterInitialization&#125;. * * @author Juergen Hoeller * @since 10.10.2003 * @see InstantiationAwareBeanPostProcessor * @see DestructionAwareBeanPostProcessor * @see ConfigurableBeanFactory#addBeanPostProcessor * @see BeanFactoryPostProcessor */public interface BeanPostProcessor &#123; /** * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean * initialization callbacks (like InitializingBean's &#123;@code afterPropertiesSet&#125; * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original. * @param bean the new bean instance * @param beanName the name of the bean * @return the bean instance to use, either the original or a wrapped one; * if &#123;@code null&#125;, no subsequent BeanPostProcessors will be invoked * @throws org.springframework.beans.BeansException in case of errors * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet */ Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; /** * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean * initialization callbacks (like InitializingBean's &#123;@code afterPropertiesSet&#125; * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original. * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean * instance and the objects created by the FactoryBean (as of Spring 2.0). The * post-processor can decide whether to apply to either the FactoryBean or created * objects or both through corresponding &#123;@code bean instanceof FactoryBean&#125; checks. * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a * &#123;@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method, * in contrast to all other BeanPostProcessor callbacks. * @param bean the new bean instance * @param beanName the name of the bean * @return the bean instance to use, either the original or a wrapped one; * if &#123;@code null&#125;, no subsequent BeanPostProcessors will be invoked * @throws org.springframework.beans.BeansException in case of errors * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet * @see org.springframework.beans.factory.FactoryBean */ Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; 注释文档很长，也很详细，简而言之呢，这是spring留给使用者的钩子接口，这个接口有两个钩子，一个是在bean初始化之前调用，也就是第三步invokeInitMethods()方法调用之前调用，另一个钩子则是在第三步骤调用之后调用，也就是后面要讲的第四步骤applyBeanPostProcessorsAfterInitialization()方法。这个钩子的用途很多很多，各种各种的定制化的东西都可以利用这个钩子实现，比如AOP(面向切面编程)中的切面就可以用这个钩子来实现，又或者你对某个bean使用了注解，那么这个钩子也可以当作注解解释器来使用呢，总之很有用就对了！ 接下来看看invokeInitMethods()方法的实现，也就是今天InitializingBean的afterPropertiesSet()方法的调用处，当然，肯定不是这么简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Give a bean a chance to react now all its properties are set, * and a chance to know about its owning bean factory (this object). * This means checking whether the bean implements InitializingBean or defines * a custom init method, and invoking the necessary callback(s) if it does. * @param beanName the bean name in the factory (for debugging purposes) * @param bean the new bean instance we may need to initialize * @param mbd the merged bean definition that the bean was created with * (can also be &#123;@code null&#125;, if given an existing bean instance) * @throws Throwable if thrown by init methods or by the invocation process * @see #invokeCustomInitMethod */ protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) throws Throwable &#123; //首先判断是否是实现了InitializingBean接口 boolean isInitializingBean = (bean instanceof InitializingBean); //如果是，日志记录并调用InitializingBean接口的钩子方法afterPropertiesSet() if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\"); &#125; if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((InitializingBean) bean).afterPropertiesSet(); return null; &#125; &#125;, getAccessControlContext()); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; ((InitializingBean) bean).afterPropertiesSet(); &#125; &#125; //如果bean定义不为空 if (mbd != null) &#123; //获取定义的初始化方法，并确保初始化方法名不是afterPropertiesSet之后，调用初始化方法 String initMethodName = mbd.getInitMethodName(); if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; \"afterPropertiesSet\".equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; //这里具体实现不细讲，大概就是根据bean定义的构造方法和初始化方法是否是public，然后通过不同处理进行反射调用 invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125; &#125; 上面代码我已经加了相关注释，大致就是如果bean实现了INitializingBean接口，会先调用其钩子方法，然后判断bean定义中是否还有init方法，如果有即调用，这里多说一句，init方法是通过bean配置的时候，有一个配置项叫init-method 来配置的。 最后来看看第四步骤applyBeanPostProcessorsAfterInitialization()方法： 12345678910111213@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessAfterInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 和第二步骤的applyBeanPostProcessorsBeforeInitialization方法如出一辙，都是获取了所有的BeanPostProcessor，然后调用其postProcessAfterInitialization()钩子方法。没什么好讲的。","tags":[{"name":"java","slug":"java","permalink":"http://qgxiaojin.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://qgxiaojin.com/tags/spring/"},{"name":"myBatis","slug":"myBatis","permalink":"http://qgxiaojin.com/tags/myBatis/"}]},{"title":"沉寂一年的结构化思维","date":"2017-03-24T14:11:20.000Z","path":"2017/03/24/沉寂一年的结构化思维/","text":"今天在团队内部做了一次2016财年的年度汇报，本来觉得PPT写的不错，想表达的东西在逻辑思维方面也够清晰，但是真正在演讲的时候，和想象中的沉着稳定，谈笑风生，还是有很大的差距。 自我回顾：在演讲一开始的两分钟，讲得尚可，没有明显的停顿，也知道自己要讲什么，然后在讲到我第二块想表达的PPT之后，这时候思维开始由点混乱，出了一点差错之后，整个人不由得紧张起来，心里想的是：“讲错了怎么办，怎么办，哦多茄。。” ,之后语速明显加快，口误也出现了几次，想表达的东西也没有表达完全，导致整个演讲过程草草结束，结束后同时很明显的指出了我的问题：紧张、思维不是很清晰，提炼不够。真是尴尬了，心境还不够啊。 会议结束后，回顾起来真是不堪入目，这时候想起了年初我写的个人规划，其中一项就是把之前参加的结构化逻辑思维能够熟练运用起来，运用到生活当中，现在想想，这个目标并没有实现，今天把当时画的xmind再拿出来看看，定下目标，上半年一定要培养出这种思维习惯。 个人感悟： 演讲的时候千万不能紧张，一紧张肯定就错漏百出，时候培养自己的心境，在能力达到一定的高度之前，演讲前必须打草稿，自己模拟演讲一遍。 在对外演讲的时候，最好采取总分总结构，确定受众之后，尽量提炼自己的PPT，以及自己想要表达的东西，确保听众能够听懂但内容又不落俗套。","tags":[{"name":"感悟","slug":"感悟","permalink":"http://qgxiaojin.com/tags/感悟/"},{"name":"思维","slug":"思维","permalink":"http://qgxiaojin.com/tags/思维/"}]},{"title":"myBatis中的Spring技术探究：SqlSessionFactoryBean之FactoryBean","date":"2017-03-18T11:44:54.000Z","path":"2017/03/18/myBatis中的Spring技术探究：SqlSessionFactoryBean之FactoryBean/","text":"今天有人问了我一个问题：为什么下面这样的spring代码代码能够正常运行呢,sessionFactory这个bean是SqlSessionFactoryBean类型的，但是genericDAO的成员变量sqlSession是SqlSessionFactory类型的，为什么可以这么配置呢？我们先来看看代码： 首先是配置代码123456789&lt;!-- 这是myBatis的sessionFactory配置--&gt;&lt;bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"myDataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:META-INF/mybatis-config.xml\"/&gt;&lt;/bean&gt;&lt;bean id=\"genericDAO\" class=\"com.xiaojin.dal.common.impl.GenericDAOImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt; 接着是java代码 123456789101112131415161718192021222324252627282930313233public interface GenericDAO &#123; /** * 获取数据列表 */ List&lt;Map&lt;String, Object&gt;&gt; getList(String statement, Map&lt;String, Object&gt; param); /** * 获取单个数据对象 */ Map&lt;String, Object&gt; getObject(String statement, Map&lt;String, Object&gt; param);&#125;public class GenericDAOImpl implements GenericDAO &#123; private SqlSessionFactory sqlSession; @Override public List&lt;Map&lt;String, Object&gt;&gt; getList(String statement, Map&lt;String, Object&gt; param) &#123; try (SqlSession sqlSession = this.sqlSession.openSession()) &#123; return sqlSession.selectList(statement, param); &#125; &#125; @Override public Map&lt;String, Object&gt; getObject(String statement, Map&lt;String, Object&gt; param) &#123; try (SqlSession sqlSession = this.sqlSession.openSession()) &#123; return sqlSession.selectOne(statement, param); &#125; &#125; public void setSqlSession(SqlSessionFactory sqlSession) &#123; this.sqlSession = sqlSession; &#125;&#125; 看到这里熟悉spring技术的同学可能已经大概知道这是为什么了，不熟悉的同学可能以为SqlSessionFactoryBean是SqlSessionFactory的子类，这里我们先不讲，我们再来看看SqlSessionFactoryBean的类定义（只贴上相关的代码，其他先忽略不看）： 12345678public class SqlSessionFactoryBean implementsFactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123;private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();private SqlSessionFactory sqlSessionFactory; ...&#125; 看到这个类型定义，发现sqlSessionFacotryBean这个类并不是sqlSessionFactory的子类，只是实现了FactoryBean这个泛型接口的时候，用了SqlSessionFactory做泛型参数，另外有一个SqlSessionFacotry的成员变量，似乎还有一个专门构建SqlSessionFacotry的构建器类。 类成员变量没什么好说的，我们直接来看看FacotryBean的定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Interface to be implemented by objects used within a &#123;@link BeanFactory&#125; * which are themselves factories. If a bean implements this interface, * it is used as a factory for an object to expose, not directly as a bean * instance that will be exposed itself. * * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a * normal bean.&lt;/b&gt; A FactoryBean is defined in a bean style, but the * object exposed for bean references (&#123;@link #getObject()&#125; is always * the object that it creates. * * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can * either create objects lazily on demand or eagerly on startup. * The &#123;@link SmartFactoryBean&#125; interface allows for exposing * more fine-grained behavioral metadata. * * &lt;p&gt;This interface is heavily used within the framework itself, for * example for the AOP &#123;@link org.springframework.aop.framework.ProxyFactoryBean&#125; * or the &#123;@link org.springframework.jndi.JndiObjectFactoryBean&#125;. * It can be used for application components as well; however, * this is not common outside of infrastructure code. * * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; FactoryBean objects participate in the containing * BeanFactory's synchronization of bean creation. There is usually no * need for internal synchronization other than for purposes of lazy * initialization within the FactoryBean itself (or the like). * * @author Rod Johnson * @author Juergen Hoeller * @since 08.03.2003 * @see org.springframework.beans.factory.BeanFactory * @see org.springframework.aop.framework.ProxyFactoryBean * @see org.springframework.jndi.JndiObjectFactoryBean */public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; 看了注释，大致明白了FactoryBean的用处，实现这个接口的类主要是BeanFacotry内创建实例化的bean，这个接口的作用是让BeanFacotry内的Bean能够实现自己的工厂，来创建不是自身类型的对象。简单的说，就是在Spring容器里面的bean实现这个接口，就是创建一个和自身类型不同的类对象，这么用的理由是因为spring内部的一些bean实例化都非常复杂，很多配置信息，需要先处理一下，得到一个可用的实例，因此实现了FacotryBean接口后，可用通过实现getObject()方法，来做一些你想要的定制化处理。 那么，getObject()方法是在什么时候调用的呢？尽然是BeanFacotry容器内的Bean，那自然和BeanFacotry有关，看了一下BeanFacotry的默认实现AbstractBeanFactory中的getBean方法实现（无关的日志和其他代码已经去掉），真相已经付出水面了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory &#123; @Override public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false); &#125; protected &lt;T&gt; T doGetBean(final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //将bean名称做一个相关的转换，比如别名、以及FacotryBean的'&amp;'解引用，意思是不拿getObject方法返回的bean，而是拿实现了 FacotryBean接口的那个类对象 final String beanName = transformedBeanName(name); Object bean; // 首先从单例缓存中尝试获取bean对象 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; //获取bean bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125;else &#123; // 如果再最近的一个周期内，我们已经创建了bean，那么抛出异常 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // 如果类已经在这个容器里面定义（未实例化） BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // 没找到，查父工厂 String nameToLookup = originalBeanName(name); //由父工厂代理来获取bean if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; try &#123; //获取bean的定义，进行bean的合并性检查，可能抛出异常，不细讲 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 获取bean依赖到的bean的名称列表，并进行相关处理检查 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dependsOnBean : dependsOn) &#123; //检查被依赖的bean是否有循环依赖（即A-&gt;B，B-&gt;A) if (isDependent(beanName, dependsOnBean)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dependsOnBean + \"'\"); &#125; //在容器内注册依赖关系 registerDependentBean(dependsOnBean, beanName); //获取bean，这里其实就是先把依赖的bean初始化，防止被依赖到的bean还没实例化 getBean(dependsOnBean); &#125; &#125; // 这里是创建bean的实例 if (mbd.isSingleton()) &#123; //如果是单例，先创建已给自身的实例，并注册 sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; destroySingleton(beanName); throw ex; &#125; &#125; &#125;); //这里就是对Bean做相关的处理，返回处理后新的bean，FacotryBean的getObject方法就是在这里处理调用 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; //如果不是单例 else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; //先做预处理，然后创建bean beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; //后处理 afterPrototypeCreation(beanName); &#125; //这里就是对Bean做相关的处理，返回处理后新的bean，FacotryBean的getObject方法就是在这里处理调用 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; //Scope类型的bean的相关创建，类似Proptype，这里不细讲 else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; return (T) bean; &#125;&#125; 看完真个方法，大概知道了Bean的创建获取过程，接下来看看本期主题FacotryBean最重要的方法，getObjectForBeanInstance()的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;// 如果bean是一个解引用（上面有讲，&amp;+beanName）但又不是FacotryBean类型，抛异常if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());&#125;//如果不属于FacotryBean或者是FacotryBean的解引用（解引用即返回自身，不做处理），直接返回if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance;&#125;Object object = null;//如果类定义为空，试图从容器缓存中读取if (mbd == null) &#123; object = getCachedObjectForFactoryBean(beanName);&#125;if (object == null) &#123; //将前面实例化的bean强转为Facotry类型，因为不是这个类型不能走到这行代码 FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // 如果bean定义为空，且容器具有这个定义，直接获取 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; //这个bean是否是'合成的'，即实现了postprocessor的，具体可看org.springframework.beans.factory.config.BeanPostProcessor，或者关注后面的相关文章 boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); //获取真正的Bean对象 object = getObjectFromFactoryBean(factory, beanName, !synthetic);&#125;return object;&#125;protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123; //是单例且容器是否已经注册了这个个单例 if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123; //单例的同步锁 synchronized (getSingletonMutex()) &#123; Object object = this.factoryBeanObjectCache.get(beanName); if (object == null) &#123; //单例的实例还不存在，调用方法获取 object = doGetObjectFromFactoryBean(factory, beanName); // 这里考虑到了bean有可能做postProcess，所以再次从容器获取bean Object alreadyThere = this.factoryBeanObjectCache.get(beanName); if (alreadyThere != null) &#123; object = alreadyThere; &#125; else &#123; if (object != null &amp;&amp; shouldPostProcess) &#123; try &#123; //做postProcess处理 object = postProcessObjectFromFactoryBean(object, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's singleton object failed\", ex); &#125; &#125; this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT)); &#125; &#125; //空对象 return (object != NULL_OBJECT ? object : null); &#125; &#125; else &#123; //获取真正的bean Object object = doGetObjectFromFactoryBean(factory, beanName); if (object != null &amp;&amp; shouldPostProcess) &#123; try &#123; //postPrecess处理 object = postProcessObjectFromFactoryBean(object, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex); &#125; &#125; return object; &#125; &#125;private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName) throws BeanCreationException &#123; Object object; try &#123; //校验当前系统是否建立了安全管理器 if (System.getSecurityManager() != null) &#123; //基于封装的上下文做出系统资源访问 AccessControlContext acc = getAccessControlContext(); try &#123; object = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; return factory.getObject(); &#125; &#125;, acc); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; //没有建立系统安全管理器，则直接调用getObject方法 object = factory.getObject(); &#125; &#125; catch (FactoryBeanNotInitializedException ex) &#123; throw new BeanCurrentlyInCreationException(beanName, ex.toString()); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"FactoryBean threw exception on object creation\", ex); &#125; // Do not accept a null value for a FactoryBean that's not fully // initialized yet: Many FactoryBeans just return null then. if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException( beanName, \"FactoryBean which is currently in creation returned null from getObject\"); &#125; return object; &#125; 上面的代码所有相关的重要的部分，我均做了注释，这下流程已经很清晰了，那么回到问题上来，在使用genericDAO这个bean的时候，因为依赖到了SqlSessionFactory这个类，所以基于成员变量的名字，又调用了getBean()方法，在这里因为这个bean已经通过配置注入了bean容器，因此直接获取到相关实例，然后进行getObjectForBeanInstance（）方法的处理，后面自然就获取到了实现了FacotryBean时的泛型参数SqlSessionFactory的真正类型实例。 讲到这了，那么我们来看看SqlSessionFactoryBean的getObject()方法是怎么实现的： 123456789101112131415161718@Overridepublic SqlSessionFactory getObject() throws Exception &#123; if (this.sqlSessionFactory == null) &#123; afterPropertiesSet(); &#125; return this.sqlSessionFactory;&#125;@Overridepublic void afterPropertiesSet() throws Exception &#123; notNull(dataSource, \"Property 'dataSource' is required\"); notNull(sqlSessionFactoryBuilder, \"Property 'sqlSessionFactoryBuilder' is required\"); state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null), \"Property 'configuration' and 'configLocation' can not specified with together\"); this.sqlSessionFactory = buildSqlSessionFactory();&#125; 很明显，SqlSessionFactoryBean 定义了一个sqlSessionFacotry的类成员变量，调用了afterPropertiedSet()(熟悉spring的同学一定会觉得这个方法很熟，后面的文章会讲相关技术)方法来构建SQLSessionFacotry实例，构建的具体实现代码这里我就不贴了，有兴趣的可以去看看，大概就是先构建configuration这个类成员变量，做了各种判断，最后用这个变量作为SqlSessionFacotry的构造函数入餐构建一个DefaultSqlSessionFactory类实例。 说一句题外话，在遇到问题的时候，你最先想到的不应该是寻找别人帮助回答问题，而应该尝试自己的探索一下问题的根源，这样探索的过程的可能会遇到新的问题，继续尝试去解决这个问题，这样一来，在解决一个问题的过程中，你其实已经解决了很多相关依赖性的问题或知识。","tags":[{"name":"java","slug":"java","permalink":"http://qgxiaojin.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://qgxiaojin.com/tags/spring/"},{"name":"myBatis","slug":"myBatis","permalink":"http://qgxiaojin.com/tags/myBatis/"}]},{"title":"使用myBatis配置多个sqlSessionFactory引发的第三方数据库连接池爆满后超时的BUG探究","date":"2017-03-16T13:48:21.000Z","path":"2017/03/16/使用myBatis配置多个sqlSessionFactory引发的第三方数据库连接池爆满后超时的BUG探究 - 副本/","text":"背景:今天项目开始进行日常测试，由于有一个功能需要在运行的时候实时加载sqlmap.xml进入sqlSessionFactory的configuration里面，因此，配置了两个sqlSessionFactory,一个用来做普通的数据库操作，一个在运行时动态的加载sqlmap文件后做特殊的业务处理。 普通的sqlSessionFacotry只是简单使用了org.mybatis.spring.SqlSessionFactoryBean，然后配置了数据源以及静态的mybatis-config，如下： 1234&lt;bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"myDataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:META-INF/mybatis-config.xml\"/&gt;&lt;/bean&gt; 而在系统运行时要动态加载sqlmap文件的sqlSessionFactory，则不能直接使用Mybatis自带的SqlSessionFactoryBean，于是自己实现了一个DynamicSqlSessionFactoryBean，除了保留SqlSessionFactoryBean里面的所有变量和方法实现，额外定制了动态加载sqlmap文件的一些其他定制实现，具体在这里不阐述。配置文件如下： 12345678910&lt;bean id=\"dynamicSessionFactory\" class=\"com.xiaojin.mybatis.support.DynamicSqlSessionFactoryBean\"&gt; &lt;property name=\"dynamicSqlSessionFactoryParser\" ref=\"dynamicSessionFactoryParser\"/&gt;&lt;/bean&gt;&lt;!-- dynamicSessionFactoryParser 主要就是用来加载动态的sqlmap文件的 --&gt;&lt;bean id=\"dynamicSessionFactoryParser\" class=\"com.tmall.udcp.support.DynamicSqlSessionFactoryParser\"&gt; &lt;property name=\"configLocation\" value=\"classpath:META-INF/mybatis-dynamic-config.xml\"/&gt; &lt;property name=\"dataSource\" ref=\"myDataSource\"/&gt; &lt;property name=\"dynamicSqlMapLoadService\" ref=\"dynamicSqlMapLoadService\"/&gt;&lt;/bean&gt; 问题现象：在某个业务步骤，需要使用到动态加载到的sqlmap文件做数据库访问，加载数据，这个时候出现了一个诡异的现象，在应用启动后，开始的几次加载数据成功了，后面就一直会抛一个超时的异常。 由于是跨系统应用，在业务应用A调用核心的应用B的接口后会出现第一个异常，就是接口调用超时异常。 问题追溯：一开始以为是数据访问过慢，导致应用A调用应用B接口超时了，因为超时时间设的是3秒，而业务是有一定的复杂度的。于是对应用B的接口实现做了一整套优化，这里不细讲。 然后重新部署之后，发现问题还是存在，这个时候详细检查了系统日志，发现是报了一个获取不到数据库连接的超时异常，而出异常的代码则是开源的数据库连接池中间件Druid，部分异常日志如下： 12345678910111213141516171819 org.springframework.jdbc.support.SQLErrorCodesFactory:227 - Error while extracting database product name - falling back to empty error codes org.springframework.jdbc.support.MetaDataAccessException: Error while extracting DatabaseMetaData; nested exception is com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 5000, active 10 at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:305) ~[spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:329) ~[spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] at org.springframework.jdbc.support.SQLErrorCodesFactory.getErrorCodes(SQLErrorCodesFactory.java:214) ~[spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.setDataSource(SQLErrorCodeSQLExceptionTranslator.java:134) [spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.&lt;init&gt;(SQLErrorCodeSQLExceptionTranslator.java:97) [spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] .... Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 5000, active 10 at com.alibaba.druid.pool.DruidDataSource.getConnectionInternal(DruidDataSource.java:1071) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:898) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4544) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.filter.stat.StatFilter.dataSource_getConnection(StatFilter.java:661) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4540) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:880) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:872) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:97) ~[druid-1.0.2.jar:1.0.2] .... 于是怀疑是不是这个中间件与我们应用的某些二方包有冲突或有BUG，开始进入Druid的源码进行检查，首先进入到DruidDataSource的出错位置，部分代码如下：123456789101112public DruidPooledConnection getConnectionDirect(long maxWaitMillis) throws SQLException &#123; for (;;) &#123; //出错代码在这一行 DruidPooledConnection poolableConnection = getConnectionInternal(maxWaitMillis); if (isTestOnBorrow()) &#123; boolean validate = testConnectionInternal(poolableConnection.getConnection()); if (!validate) &#123; if (LOG.isDebugEnabled()) &#123; LOG.debug(\"skip not validate connection.\"); &#125; ..... 这里貌似没看出什么问题，于是深入这个方法的具体实现，最后发现，所有的链接都需要从DruidDataSource的一个成员变量： private volatile DruidConnectionHolder[] connections; 里面获取的，这就是一个数据库连接池，每次都在条件允许的情况下，都会取链接池的最后一个可用链接，而当我调试到这里面的时候，发现connections已经满了（10个），而且所有的链接都是不可用的（active,即活跃状态），因此就会陷入等待，超过了5000ms之后就会抛出超时异常，因此才会出现这个异常。然后调试的窗口发现所有的connections虽然都是活跃状态，但都是空的。那么结果就显而易见了，即是我们的数据库访问代码中，存在一种情况：创建连接之后，进行相关的数据库操作，之后没有将相关的链接关闭，而随着方法执行完毕，链接对象已经被回收，因此而链接池中就存在了10个null的活跃链接。 这个时候回去检查了一下相关的数据库操作代码，如下： 1234567891011121314151617181920public class DynamicDAOImpl implements DynamicDAO &#123; //这个sessionFacotry就是需要执行动态文件加载的sessionFacotry private SqlSessionFactory sqlSession; @Override public List&lt;Map&lt;String, Object&gt;&gt; getList(String statement, Map&lt;String, Object&gt; param) &#123; return this.sqlSession.openSession().selectList(statement, param); &#125; &#125; @Override public Map&lt;String, Object&gt; getObject(String statement, Map&lt;String, Object&gt; param) &#123; return this.sqlSession.openSession().selectOne(statement, param); &#125; public void setSqlSession(SqlSessionFactory sqlSession) &#123; this.sqlSession = sqlSession; &#125;&#125; 看了一下这段代码，觉得应该是openSession()方法有问题，因此看了一下openSession的DefaultSqlSessionFactory的实现代码：1234567891011121314151617181920@Overridepublic SqlSession openSession() &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);&#125;private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; try &#123; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.wrapException(\"Error opening session. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 这个方法直接创建了一个DefaultSqlSession，即数据库连接，一开始以为是ExecutorType这个参数有问题，然后看了一下官方的文档，发现这个枚举只是在做sql的PrepareStatement的一个参数而已，分别是SIMPLE（每次都使用心得PrepareSatement）,REUSE(重复使用同一种sql的PrePareStatement)，BATCH（支持批量PrePareStateMent），然后看了一下每个枚举对应的Executor的实现（这里就不详细讲了，有机会新开文章），发现确实如此，和具体的问题没有关系，于是看了一下DefaultSqlSession的具体代码： 1234567891011public class DefaultSqlSession implements SqlSession &#123;private Configuration configuration;private Executor executor;private boolean autoCommit;private boolean dirty;private List&lt;Cursor&lt;?&gt;&gt; cursorList;....&#125; 看到这里，答案已经付出水面了，因为这个类实现了SqlSession，而Mybatis的SqlSession又实现了Closeable，因此这个SqlSession是需要被手动关闭的。于是我把代码改了一下： 12345678910111213141516171819202122public class DynamicDAOImpl implements DynamicDAO &#123; private SqlSessionFactory sqlSession; @Override public List&lt;Map&lt;String, Object&gt;&gt; getList(String statement, Map&lt;String, Object&gt; param) &#123; try (SqlSession sqlSession = this.sqlSession.openSession(ExecutorType.REUSE)) &#123; return sqlSession.selectList(statement, param); &#125; &#125; @Override public Map&lt;String, Object&gt; getObject(String statement, Map&lt;String, Object&gt; param) &#123; try (SqlSession sqlSession = this.sqlSession.openSession(ExecutorType.REUSE)) &#123; return sqlSession.selectOne(statement, param); &#125; &#125; public void setSqlSession(SqlSessionFactory sqlSession) &#123; this.sqlSession = sqlSession; &#125;&#125; 然后启动应用，发现这个问题果然修复了！ 复盘:这个问题其实是一个很简单的问题，因为一时的粗心，导致找答案的时候，找错了方向，如果一开始就确定是数据连接的问题，其实这个问题很容易就找出来。 最重要的是，这个代码写的真的很不好，没有手动关闭一个链接，这真的是一个初级错误（虽然这个代码不是我写的…），很明显，会出现这个错误是因为coder对Mybatis不够熟悉了解导致的。 因此个人觉得，在使用一个开源框架的时候，在不确定是否出错的情况下，第一是先看注释，然后看看官方文档，实现不行直接看源码。","tags":[{"name":"java","slug":"java","permalink":"http://qgxiaojin.com/tags/java/"},{"name":"myBatis","slug":"myBatis","permalink":"http://qgxiaojin.com/tags/myBatis/"},{"name":"日常问题","slug":"日常问题","permalink":"http://qgxiaojin.com/tags/日常问题/"}]},{"title":"测试","date":"2017-03-16T13:48:21.000Z","path":"2017/03/16/test/","text":"背景:今天项目开始进行日常测试，由于有一个功能需要在运行的时候实时加载sqlmap.xml进入sqlSessionFactory的configuration里面，因此，配置了两个sqlSessionFactory,一个用来做普通的数据库操作，一个在运行时动态的加载sqlmap文件后做特殊的业务处理。 普通的sqlSessionFacotry只是简单使用了org.mybatis.spring.SqlSessionFactoryBean，然后配置了数据源以及静态的mybatis-config，如下： 1234&lt;bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"myDataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:META-INF/mybatis-config.xml\"/&gt;&lt;/bean&gt; 而在系统运行时要动态加载sqlmap文件的sqlSessionFactory，则不能直接使用Mybatis自带的SqlSessionFactoryBean，于是自己实现了一个DynamicSqlSessionFactoryBean，除了保留SqlSessionFactoryBean里面的所有变量和方法实现，额外定制了动态加载sqlmap文件的一些其他定制实现，具体在这里不阐述。配置文件如下： 12345678910&lt;bean id=\"dynamicSessionFactory\" class=\"com.xiaojin.mybatis.support.DynamicSqlSessionFactoryBean\"&gt; &lt;property name=\"dynamicSqlSessionFactoryParser\" ref=\"dynamicSessionFactoryParser\"/&gt;&lt;/bean&gt;&lt;!-- dynamicSessionFactoryParser 主要就是用来加载动态的sqlmap文件的 --&gt;&lt;bean id=\"dynamicSessionFactoryParser\" class=\"com.tmall.udcp.support.DynamicSqlSessionFactoryParser\"&gt; &lt;property name=\"configLocation\" value=\"classpath:META-INF/mybatis-dynamic-config.xml\"/&gt; &lt;property name=\"dataSource\" ref=\"myDataSource\"/&gt; &lt;property name=\"dynamicSqlMapLoadService\" ref=\"dynamicSqlMapLoadService\"/&gt;&lt;/bean&gt; 问题现象：在某个业务步骤，需要使用到动态加载到的sqlmap文件做数据库访问，加载数据，这个时候出现了一个诡异的现象，在应用启动后，开始的几次加载数据成功了，后面就一直会抛一个超时的异常。 由于是跨系统应用，在业务应用A调用核心的应用B的接口后会出现第一个异常，就是接口调用超时异常。 问题追溯：一开始以为是数据访问过慢，导致应用A调用应用B接口超时了，因为超时时间设的是3秒，而业务是有一定的复杂度的。于是对应用B的接口实现做了一整套优化，这里不细讲。 然后重新部署之后，发现问题还是存在，这个时候详细检查了系统日志，发现是报了一个获取不到数据库连接的超时异常，而出异常的代码则是开源的数据库连接池中间件Druid，部分异常日志如下： 12345678910111213141516171819 org.springframework.jdbc.support.SQLErrorCodesFactory:227 - Error while extracting database product name - falling back to empty error codes org.springframework.jdbc.support.MetaDataAccessException: Error while extracting DatabaseMetaData; nested exception is com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 5000, active 10 at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:305) ~[spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:329) ~[spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] at org.springframework.jdbc.support.SQLErrorCodesFactory.getErrorCodes(SQLErrorCodesFactory.java:214) ~[spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.setDataSource(SQLErrorCodeSQLExceptionTranslator.java:134) [spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.&lt;init&gt;(SQLErrorCodeSQLExceptionTranslator.java:97) [spring-jdbc-4.3.0.RC2.jar:4.3.0.RC2] .... Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 5000, active 10 at com.alibaba.druid.pool.DruidDataSource.getConnectionInternal(DruidDataSource.java:1071) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:898) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4544) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.filter.stat.StatFilter.dataSource_getConnection(StatFilter.java:661) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4540) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:880) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:872) ~[druid-1.0.2.jar:1.0.2] at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:97) ~[druid-1.0.2.jar:1.0.2] .... 于是怀疑是不是这个中间件与我们应用的某些二方包有冲突或有BUG，开始进入Druid的源码进行检查，首先进入到DruidDataSource的出错位置，部分代码如下：123456789101112public DruidPooledConnection getConnectionDirect(long maxWaitMillis) throws SQLException &#123; for (;;) &#123; //出错代码在这一行 DruidPooledConnection poolableConnection = getConnectionInternal(maxWaitMillis); if (isTestOnBorrow()) &#123; boolean validate = testConnectionInternal(poolableConnection.getConnection()); if (!validate) &#123; if (LOG.isDebugEnabled()) &#123; LOG.debug(\"skip not validate connection.\"); &#125; ..... 这里貌似没看出什么问题，于是深入这个方法的具体实现，最后发现，所有的链接都需要从DruidDataSource的一个成员变量： private volatile DruidConnectionHolder[] connections; 里面获取的，这就是一个数据库连接池，每次都在条件允许的情况下，都会取链接池的最后一个可用链接，而当我调试到这里面的时候，发现connections已经满了（10个），而且所有的链接都是不可用的（active,即活跃状态），因此就会陷入等待，超过了5000ms之后就会抛出超时异常，因此才会出现这个异常。然后调试的窗口发现所有的connections虽然都是活跃状态，但都是空的。那么结果就显而易见了，即是我们的数据库访问代码中，存在一种情况：创建连接之后，进行相关的数据库操作，之后没有将相关的链接关闭，而随着方法执行完毕，链接对象已经被回收，因此而链接池中就存在了10个null的活跃链接。 这个时候回去检查了一下相关的数据库操作代码，如下： 1234567891011121314151617181920public class DynamicDAOImpl implements DynamicDAO &#123; //这个sessionFacotry就是需要执行动态文件加载的sessionFacotry private SqlSessionFactory sqlSession; @Override public List&lt;Map&lt;String, Object&gt;&gt; getList(String statement, Map&lt;String, Object&gt; param) &#123; return this.sqlSession.openSession().selectList(statement, param); &#125; &#125; @Override public Map&lt;String, Object&gt; getObject(String statement, Map&lt;String, Object&gt; param) &#123; return this.sqlSession.openSession().selectOne(statement, param); &#125; public void setSqlSession(SqlSessionFactory sqlSession) &#123; this.sqlSession = sqlSession; &#125;&#125; 看了一下这段代码，觉得应该是openSession()方法有问题，因此看了一下openSession的DefaultSqlSessionFactory的实现代码：1234567891011121314151617181920@Overridepublic SqlSession openSession() &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);&#125;private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; try &#123; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.wrapException(\"Error opening session. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 这个方法直接创建了一个DefaultSqlSession，即数据库连接，一开始以为是ExecutorType这个参数有问题，然后看了一下官方的文档，发现这个枚举只是在做sql的PrepareStatement的一个参数而已，分别是SIMPLE（每次都使用心得PrepareSatement）,REUSE(重复使用同一种sql的PrePareStatement)，BATCH（支持批量PrePareStateMent），然后看了一下每个枚举对应的Executor的实现（这里就不详细讲了，有机会新开文章），发现确实如此，和具体的问题没有关系，于是看了一下DefaultSqlSession的具体代码： 1234567891011public class DefaultSqlSession implements SqlSession &#123;private Configuration configuration;private Executor executor;private boolean autoCommit;private boolean dirty;private List&lt;Cursor&lt;?&gt;&gt; cursorList;....&#125; 看到这里，答案已经付出水面了，因为这个类实现了SqlSession，而Mybatis的SqlSession又实现了Closeable，因此这个SqlSession是需要被手动关闭的。于是我把代码改了一下： 12345678910111213141516171819202122public class DynamicDAOImpl implements DynamicDAO &#123; private SqlSessionFactory sqlSession; @Override public List&lt;Map&lt;String, Object&gt;&gt; getList(String statement, Map&lt;String, Object&gt; param) &#123; try (SqlSession sqlSession = this.sqlSession.openSession(ExecutorType.REUSE)) &#123; return sqlSession.selectList(statement, param); &#125; &#125; @Override public Map&lt;String, Object&gt; getObject(String statement, Map&lt;String, Object&gt; param) &#123; try (SqlSession sqlSession = this.sqlSession.openSession(ExecutorType.REUSE)) &#123; return sqlSession.selectOne(statement, param); &#125; &#125; public void setSqlSession(SqlSessionFactory sqlSession) &#123; this.sqlSession = sqlSession; &#125;&#125; 然后启动应用，发现这个问题果然修复了！ 复盘:这个问题其实是一个很简单的问题，因为一时的粗心，导致找答案的时候，找错了方向，如果一开始就确定是数据连接的问题，其实这个问题很容易就找出来。 最重要的是，这个代码写的真的很不好，没有手动关闭一个链接，这真的是一个初级错误（虽然这个代码不是我写的…），很明显，会出现这个错误是因为coder对Mybatis不够熟悉了解导致的。 因此个人觉得，在使用一个开源框架的时候，在不确定是否出错的情况下，第一是先看注释，然后看看官方文档，实现不行直接看源码。","tags":[{"name":"java","slug":"java","permalink":"http://qgxiaojin.com/tags/java/"},{"name":"myBatis","slug":"myBatis","permalink":"http://qgxiaojin.com/tags/myBatis/"},{"name":"日常问题","slug":"日常问题","permalink":"http://qgxiaojin.com/tags/日常问题/"}]},{"title":"Intellij Idea Method threw java.lang.NullPointerException exception. Cannot evaluate XXXX.toString()引出的问题探究","date":"2017-03-13T12:29:48.000Z","path":"2017/03/13/Intellij-Idea-Method-threw-java-lang-NullPointerException-exception-Cannot-evaluate-XXXX-toString-引出的问题探究/","text":"今天用IntelliJ Idea14在调试一个用例的时候，在某一个步骤，发现了一个Idea自身报错的现象，如图： 虽然平时正常运行的时候，并不会报这个错误，但好奇驱使下，我决定研究一下，于是我检查了一下报错的类代码（由于出错代码是公司项目代码，我自己重写了一个能触发同样错误的类）： 123456789101112131415161718192021222324252627282930313233public class NPETestDO &#123; @Getter @Setter private String testA; @Getter @Setter private String testB; @Override public int hashCode() &#123; return NPETestDO.class.getName() .concat(this.testA) .concat(this.testB) .hashCode(); &#125; @Override public boolean equals(Object obj) &#123; if(obj == this)&#123; return true; &#125; if (!(obj instanceof NPETestDO)) &#123; return false; &#125; NPETestDO other = (NPETestDO) obj; return this.testA.equals(other.testA) &amp;&amp; this.testB.equals(other.testB); &#125;&#125; 乍看之下似乎并没有什么问题，这里只重写了hashCode()和equals()方法，都没有重写toString方法，toString方法怎么会报NPE错误呢，于是我看了一个Object的toString实现，瞬间了然： 1234567891011121314151617181920public class Object &#123; //其他无关代码忽略并没有贴上来 public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); &#125;&#125;public final class String &#123; public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125;&#125; 原来是Object的toString实现中 调用了自身的hashCode()方法,而在这个类重写的的hashCode()方法中，将自身的变量testA和testB作为参数传入到了String.concat()的方法中,当testA和testB其中一个为null的时候，concat的第一行实现代码int ohterLen = str.length()就会触发空指针异常。 而Idea在调试模式的时候，调试板上面会默认会调用类对象的toString()方法，然后将返回内容展示在调试窗口中，当这个类的testA或testB还没有被初始化值的时候，就会报上图所展示的那个错误。 然后我就想这个调试会调用类对象的toString()方法功能能不能关闭，找了一圈之后，发现还真的可以关闭，而且还提供指定类列表才调用toString方法的功能。就在： settings-&gt;Build,Execution,Deployment-&gt;Debugger-&gt;Data views -&gt;java-&gt;Enable ‘toString()’ Object View 选项。 然后我觉得这个异常在运行时也很有可能出现，于是把类的hashCode()和equals()方法改了一下： 12345678910111213141516171819202122232425262728293031323334353637383940public class NPETestDO &#123; @Getter @Setter private String testA; @Getter @Setter private String testB; @Override public int hashCode() &#123; if(this.testA == null || this.testB == null)&#123; return 0; &#125; return NPETestDO.class.getName() .concat(this.testA) .concat(this.testB) .hashCode(); &#125; @Override public boolean equals(Object obj) &#123; if(obj == null)&#123; return false; &#125; if(obj == this)&#123; return true; &#125; if (!(obj instanceof NPETestDO)) &#123; return false; &#125; if(this.testA == null || this.testB == null)&#123; return false; &#125; NPETestDO other = (NPETestDO) obj; return this.testA.equals(other.testA) &amp;&amp; this.testB.equals(other.testB); &#125;&#125; 这样即使在类对象还没有实例化完全的时候被使用来做比较和hashCode或toString，也不会出现NPE异常了。 任何一个可能出现异常或错误的代码都应该被修复，即使这个错误只有千万分之一的几率发生，必须怀着敬畏之心看待每一行代码。","tags":[{"name":"java","slug":"java","permalink":"http://qgxiaojin.com/tags/java/"},{"name":"日常问题","slug":"日常问题","permalink":"http://qgxiaojin.com/tags/日常问题/"}]},{"title":"浅谈设计模式：适配器模式（Adapter Pattern）","date":"2017-03-09T13:56:10.000Z","path":"2017/03/09/浅谈设计模式：适配器模式（Adapter-Pattern）/","text":"什么是适配器模式？ 官方解释： Convert the interface of a class into another interface clients expect。 将一个类的接口转换成另外一个客户端想要的接口。 通俗解释：客户端期望能有某一个接口，但是当前仅有一个功能相似但又不全部相同的接口，需要一个适配器将这个借口稍加处理包装（继承、组合）成客户端所期望的接口。 为什么使用适配器模式？ -原来由于接口不兼容而不能在一起工作的那些类可以一起工作。 希望复用一些现存的类，但是接口又与复用环境要求不一致。 被适配的接口对于客户端来说是透明的，简单直接。 将目标类与被适配者解耦，使得被适配者无需直接在目标类上进行修改处理。 一个对象适配器可以把多个不同的适配者类适配到同一个目标 PS：适配器在最初设计的时候就不应出现，适配器只适合在你前期设计考虑不周，后续新的业务需求进来后进行功能上的增加、代码上的重构的时候使用。 如何使用适配器模式？适配器的UML图如下： Client：需要调用到最终适配好的接口的客户端类。 Target：所期待的接口形式。 Adapter：适配器，继承了Target。类适配器继承了Adaptee，对象适配器聚合了Adaptee。 Adaptee：被适配的类。 应用场景： 系统需要使用现有的类，而这些类的接口不符合系统的接口规范。 想要建立一个可重用类，与一些彼此之间没有关联的类，包括一些可能在将来引进的类一起工作。（很少因为这种情况使用） 系统前期开发已经实现了一些功能，新的功能需求只能以另外接口的形式访问，不希望手动更改原有类的时候。（大部分情况） 使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能。（大部分情况） 简单实现（对象适配器）：1234567891011121314151617181920212223242526272829303132public interface Target &#123; public void expectedOperation();&#125;public class Adaptee &#123; public void exitedOperation()&#123; System.out.println(\"this function is old function to do something!\"); &#125;&#125;public class Adapter implements Target&#123; private Adaptee adaptee = new Adaptee(); @Override public void expectedOperation() &#123; adaptee.exitedOperation(); System.out.println(\"this function is client expected interface，it was adapted the Adaptee\"); &#125;&#125;public class Client &#123; private Target target = new Adapter(); public void bizOperation()&#123; target.expectedOperation(); &#125; public static void main(String[] args)&#123; Client client = new Client(); client.bizOperation(); &#125;&#125;","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：装饰器模式（Decorator Pattern）","date":"2017-03-09T13:51:54.000Z","path":"2017/03/09/浅谈设计模式：装饰器模式（Decorator-Pattern）/","text":"什么是装饰器模式？ 官方解释： The Decorator Pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. 装饰器模式动态地给一个对象添加了一些额外的职责，装饰器提供了一个灵活可变的子类来拓展功能。 通俗解释：装饰器模式可以在运行时动态地给一个类对象增加功能。 为什么使用装饰器模式？ 使用组合的方式，而不是通过继承对象来拓展一个类的功能。 把复杂的功能简单化，分散化，然后根据需要来动态组合。 将各个功能点解耦，使得每个功能点能独立存在不依赖其他类。 在不影响其他对象的情况下，以动态、透明的方式给对象添加职责。 如何使用装饰器模式？装饰器的UML图如下： Component：功能类接口，定义了类的一些功能接口。 ConcreteComponent：具体功能类定义，实现了功能类接口的方法。 Decorator：装饰器基类，实现了功能类接口，并简单定义了装饰方法。 ConcreteDecorator：具体装饰器类，继承自Decorator，具体定义了要装饰的内容（操作）。 样例： 假设我们有这么一个需求，我要渲染一个窗口，这个窗口可以是实体的，也可以是半透明的，除此之外这个窗口还可以带有一些附属控件，比如菜单、子窗口等。现在要求每一个类型的窗口都可以自由搭配不同的附属控件。 实现：1、 定义一个渲染简单窗口的接口。123public interface Window &#123; void drawSimpleWindow();&#125; 2、 继承上述接口定义窗口的类型。12345678910111213public class SolidWindow implements Window &#123; @Override public void drawSimpleWindow() &#123; System.out.println(\"渲染一个实体不透明窗口！！！\"); &#125;&#125;public class TranslucenceWindow implements Window &#123; @Override public void drawSimpleWindow() &#123; System.out.println(\"渲染一个半透明窗口！！！\"); &#125;&#125; 3、 定义一个装饰器基类，聚合了窗口接口，其中声明了渲染操作前后要装饰内容的接口。123456789101112131415public abstract class Decorator implements Window&#123; protected Window window; public Decorator(Window window)&#123; this.window = window; &#125; @Override public void drawSimpleWindow() &#123; doBeforeDraw(); window.drawSimpleWindow(); doAfterDraw(); &#125; protected abstract void doBeforeDraw(); protected abstract void doAfterDraw();&#125; 4、 定义具体装饰器类，并实现要装饰的内容。12345678910111213141516171819202122232425262728293031public class MenuDecorator extends Decorator &#123; public MenuDecorator(Window window) &#123; super(window); &#125; @Override protected void doBeforeDraw() &#123; System.out.println(\"渲染一个窗口的菜单！！！\"); &#125; @Override protected void doAfterDraw() &#123; //do nothing &#125;&#125;public class SubWindowDecorator extends Decorator &#123; public SubWindowDecorator(Window window) &#123; super(window); &#125; @Override protected void doBeforeDraw() &#123; //do nothing &#125; @Override protected void doAfterDraw() &#123; System.out.println(\"渲染一个窗口的子窗口！\"); &#125;&#125; 5、测试 1234567891011public class DecoratorTest &#123; public static void main(String[] args)&#123; //渲染一个带有菜单和子窗口的实体窗口 Window windowA = new SubWindowDecorator(new MenuDecorator(new SolidWindow())); windowA.drawSimpleWindow(); System.out.println(\"---------------------------------------\"); //渲染一个带有菜单的半透明窗口 Window windowB = new MenuDecorator(new TranslucenceWindow()); windowB.drawSimpleWindow(); &#125;&#125;","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：状态模式（State Pattern）","date":"2017-03-09T13:46:55.000Z","path":"2017/03/09/浅谈设计模式：状态模式（State-Pattern）/","text":"什么是状态模式？ 官方解释： State pattern is one of the behavioral design pattern. State design pattern is used when an Object change it’s behavior based on it’s internal state. 状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。 为什么使用状态模式？ 如果一个类的某个方法在不同的状态下可能展现出不同的行为，那么为了减少if语句，可以采用状态模式。 将不同的行为与相关的类解耦，使得某种状态下的状态只与相关的状态有关。 封装了转换过程，对于外部来说，暴露的一个具有行为变换的接口。 缺点：当状态过多的时候，程序会出现过多的类。结构会变得比较分散，阅读的时候比较不方便。如何使用状态模式？状态模式的UML图如下： Context：客户类，聚合了一个State接口对象，该对象随着类的某些操作会动态改变其具体的引用。 State：状态接口，定义了某些接口，以封装与Context的本状态相对应的行为。 ConcreteState（AState、BState等）：具体状态，每一个类实现了该状态下与Context的某些行为相对应的具体行为。 简单实现：如上的UML图所示，该类的AB行为具有ABC三种状态，状态之间的转换由状态自己决定。假设上述的状态的状态机如下： 即： A状态：执行操作A后状态转换成B，执行操作B后状态转换成C。 B状态：执行操作A后状态转换成C，执行操作B后状态转换成A。 C状态：执行操作A后状态转换成A，执行操作B后状态转换成B。 具体代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public interface State &#123; State operationA(); State operationB();&#125;public class AState implements State &#123; @Override public State operationA() &#123; System.out.println(\"A state's operationA\"); return new BState(); &#125; @Override public State operationB() &#123; System.out.println(\"A state's operationB\"); return new CState(); &#125;&#125;public class BState implements State &#123; @Override public State operationA() &#123; System.out.println(\"B state's operationA\"); return new CState(); &#125; @Override public State operationB() &#123; System.out.println(\"B state's operationB\"); return new AState(); &#125;&#125;public class CState implements State&#123; @Override public State operationA() &#123; System.out.println(\"C state's operationA\"); return new AState(); &#125; @Override public State operationB() &#123; System.out.println(\"C state's operationB\"); return new BState(); &#125;&#125;public class Context &#123; private State state = new AState(); public void operationA()&#123; state = state.operationA(); &#125; public void operationB()&#123; state = state.operationB(); &#125; public static void main(String [] args)&#123; Context context = new Context(); for(int i = 0; i &lt; 12; ++i)&#123; context.operationA(); &#125; for(int i = 0; i &lt; 12; ++i)&#123; context.operationB(); &#125; &#125;&#125; 状态模式的实现方式有很多种，你可以使用纯接口方式（即上述方式），也可以使用枚举方式（结合java强大的枚举功能很容易实现），但千变万化不离其终，即状态模式本身想表达的允许一个对象在其内部状态改变的时候改变其行为。 所以说不要纠结于何种实现方式比较好，需要考虑的因素很多，具体的业务场景，不同的语言特性等等，可以这么说，模式是死的，设计是活的（可变的），业务场景是活的（可变的），实现代码是活的（灵活可变的），实现思想的不变的。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：模版方法（Template Method）","date":"2017-03-09T13:43:41.000Z","path":"2017/03/09/浅谈设计模式：模版方法（Template-Method）/","text":"什么是模版方法？ 官方解释： Define the skeleton of an algorithm in an operation, deferring some steps to subclasses。 定义一个操作的算法骨架，将某些步骤延迟到子类实现。 通俗解释：一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 为什么使用模版方法： 模板方法允许子类定义一个算法的某些步骤，而不让它们改变算法的结构。 各子类中公共的行为提取出来并集中到一个公共父类中以避免代码重复。提高代码的可用性、复用性，提供了一个很好的代码复用平台。 算法骨架不变，而某些步骤可以延迟到子类来实现，不同的子类定义了这些可变操作的不同实现。具有很高的灵活性。 如何使用模版方法： AbstractTemplateClass:抽象模版方法类，定义了一个算法的骨架，如图所示，主操作方法（operationMain）中一次定义了操作的组合顺序。operationA、B、C方法为抽象方法，没有提供具体实现，延迟到子类实现。 ComcreteTemplateClass：具体模版方法实现类，继承了抽象模版方法类的主操作方法，实现了算法骨架可变部分的方法，如图中的operationA、B、C。 示例： 有这样一个场景，本地一个商品数据库管理者一些商品、商家、店铺的数据，每次从数据库取出来的数据和写入数据的操作是不变的，对数据的操作处理是可变的，可能是对这一块数据的商家部分处理或者商品部分处理。 实现：1、 定义一个抽象模版方法：AbstractDataProcessor，其中包含了数据操作主方法，方法内调用了读数据、写数据的不可变部分，以及处理数据的可变部分（抽象方法）。1234567891011121314abstract public class AbstractDataProcessor &#123; public void dealDataMain()&#123; readData(); dealData(); writeData(); &#125; protected void readData()&#123; System.out.println(\"从数据库中读取数据\"); &#125; protected void writeData()&#123; System.out.println(\"将处理完的数据写入到数据库\"); &#125; protected abstract void dealData();&#125; 2、 分别实现商品数据处理器、商家数据处理器类。123456789101112public class ItemDataProcessor extends AbstractDataProcessor&#123; @Override protected void dealData() &#123; System.out.println(\"处理商品数据，如改价格、数量等操作！\"); &#125;&#125;public class SellerDataProcessor extends AbstractDataProcessor &#123; @Override protected void dealData() &#123; System.out.println(\"处理商家数据，如改商家信用值、商家关联店铺等！\"); &#125;&#125; 3、 编写测试类123456789public class TemplateMethodTest &#123; public static void main(String args[])&#123; AbstractDataProcessor itemDataProcessor = new ItemDataProcessor(); itemDataProcessor.dealDataMain(); AbstractDataProcessor sellerDataProcessor = new SellerDataProcessor(); sellerDataProcessor.dealDataMain(); &#125;&#125;","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：策略模式（Strategy Pattern）","date":"2017-03-09T13:37:54.000Z","path":"2017/03/09/浅谈设计模式：策略模式（Strategy-Pattern）/","text":"什么是策略模式？ 官方解释： Definea family of algorithms,encapsulate each one, and make theminterchangeable. Strategy lets the algorithmvary independently fromclients that use it. 定义一系列算法并将其封装，使他们能互相替换，该模式能使这些算法独立于使用它的客户端。 通俗解释：定义一种算法类型并具有多种具体实现，让使用这些算法的客户端不强依赖具体的算法实现而仅仅依赖于算法的类型，使得具体算法独立于客户端而能灵活变化。 为什么使用策略模式？ 客户端不必依赖具体的算法实现，减小两者的耦合性。 具体算法实现可以有多种，增强客户使用的灵活性。 客户与具体算法互相独立，算法可重用性强。 消除了冗余的if –else 或switch-case等代码语句，当一个类的某一个行为具有多种具体方式时，通常将一些互补相关的代码整合到一个方法中，使用if-else或swich-case来进行判断使用，该模式实现客户与算法分离独立，减少了这些冗余的判断。 缺点： 客户端虽然与算法相独立，但是必须知道所有的算法实现，并自行决定使用哪一个。 增加了客户与算法之间的通信开销，可能某些算法需要的参数不一致而导致某些算法并没有（不需要）用到实际通信传输的参数。 模式实现将造成类数量比较多，多少个算法实现变有多少的算法子类。 如何使用策略模式？ Context：具体使用策略的客户，维护一个对Strategy对象的引用。 Strategy：抽象的策略接口，Context直接使用该接口来调用具体的策略方法。 StrategyA：具体策略实现。 使用场景： 一个类（或一种类）具有多个相似行为的方法（接口）。 某一个算法（功能）有多种不同的变体（实现方式）。 用策略模式以避免暴露复杂的、与算法相关的数据结构。 一个类的某一个方法集成了多种相似的行为，并使用if-else等判断语句来进行判断使用哪种行为，策略模式可以将相关行为以接口方式移植进去来避免使用if-else等判断语句。 使用样例：假设现在有一个商品类，包含了商品id、名称、价格等信息，但是通过不同的支付方式价格可能会有变化，如：支付宝支付是9折、微信支付是9.5折，现金支付不打折（假设只支持者三种支付）。 实现：1、 设计一个计算商品价格的策略接口Calculator：1234public interface Calculator &#123; public double calculatePrice(double price);&#125; 2、 提供三种策略实现 AlipayCalculator、WeixinPayCalculator、CashCalculator：123456789101112131415161718192021public class AlipayCalculator implements Calculator &#123; @Override public double calculatePrice(double price) &#123; return price * 0.9; &#125;&#125;public class WeixinPayCalculator implements Calculator &#123; @Override public double calculatePrice(double price) &#123; return price * 0.95; &#125;&#125;public class WeixinPayCalculator implements Calculator &#123; @Override public double calculatePrice(double price) &#123; return price * 0.95; &#125;&#125; 3、 设计商品类：1234567891011121314151617181920public class Item &#123; private Calculator calculator; private double itemPrice; private String itemId; private String itemName; public Item(String itemId, String itemName, double itemPrice)&#123; this.itemId = itemId; this.itemName = itemName; this.itemPrice = itemPrice; &#125; public double getFinalPrice()&#123; return calculator.calculatePrice(this.itemPrice); &#125; public Calculator getCalculator() &#123; return calculator; &#125; public void setCalculator(Calculator calculator) &#123; this.calculator = calculator; &#125;&#125; 4、 测试123456789101112131415public class StrategyTest &#123; public static void main(String [] args)&#123; Item meat = new Item(\"1001\", \"猪肉\", 100L); Calculator alipayCalculator = new AlipayCalculator(); Calculator weixinPayCalculator = new WeixinPayCalculator(); Calculator cashCalculator = new CashPayCalculator(); meat.setCalculator(alipayCalculator); System.out.println(\"支付宝支付价格：\" + meat.getFinalPrice()); meat.setCalculator(weixinPayCalculator); System.out.println(\"微信支付价格：\" + meat.getFinalPrice()); meat.setCalculator(cashCalculator); System.out.println(\"现金支付价格：\" + meat.getFinalPrice()); &#125;&#125; PS：这里仅是提供了一种简单的样例实现，实际中价格是不能用double类型来实现的，一般价格用的是Long型，单位为分，另外商品一般也不会依赖到计算接口，一般是有另外的优惠计算服务类依赖优惠计算器。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：观察者模式（Observer Pattern）","date":"2017-03-09T13:28:37.000Z","path":"2017/03/09/浅谈设计模式：观察者模式（Observer-Pattern）/","text":"什么是观察者模式？ 官方解释： Defines a one-to-many dependency between objects so that when oneobject changes state, all its dependents are notified and updatedautomatically. 在对象之间定义一个一对多的依赖关系，当一个对象状态变更时，所有依赖的对象也随着自动更新。 通俗解释：某些对象（观察者）对某个特定的对象（被观察者）感兴趣，想让这个对象在状态变更的时候能即时得到通知，好做出相对应的变化。因此这个对象便注册了这个观察者对象，增加到自身的观察者依赖列表中。当自身状态变更时将信息通知到这个依赖列表的所有观察者中。 为什么使用观察者模式？ 当抽象个体有两个互相依赖的层面时。封装这些层面在单独的对象内将可允许程序员单独地去变更与重复使用这些对象，而不会产生两者之间交互的问题。 当其中一个对象的变更会影响其他对象，却又不知道多少对象必须被同时变更时。 当对象应该有能力通知其他对象，又不应该知道其他对象的实做细节时。 如何使用命令模式？ Subject：抽象主题类，内聚了一个抽象Observer列表，定义了增加观察者、删除观察者、通知观察者等基本方法。 Observer：抽象观察者类，声明了一个更新接口。 ConcreteSubject：具体主题类，定义了特有的状态信息，以及要通知到的信息。 ConcreteObserver：具体观察者类，定义了当依赖的主题类信息变更的时的具体操作。 具体用例：场景：现在有一个互联网报社基站，需要当有新的报刊信息将信息的发送到订阅了的用户邮箱上。一个基站可能包含了不同的分类报刊信息，如JAVA、C++、PHP等，而用户的喜好也各不相同，仅仅选择喜欢的分类来订阅。 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** 抽象主题类**/public class MessagePublisher &#123; private List&lt;Observer&gt; subscriberList = new ArrayList&lt;Observer&gt;(); public void addSubscriber(Observer observer) &#123; subscriberList.add(observer); &#125; public void remove(Observer observer) &#123; subscriberList.remove(subscriberList.indexOf(observer)); &#125; public void notifySubscribers(String state) &#123; for(Observer observer : subscriberList)&#123; observer.update(state); &#125; &#125;&#125;/** 抽象观察者**/interface Observer &#123; void update(String state);&#125;/** 具体主题类**/public class JavaMessagePublisher extends MessagePublisher &#123; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; notifySubscribers(state); &#125;&#125;/** 具体主题类**/public class PHPMessagePublisher extends MessagePublisher &#123; private String state; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; notifySubscribers(state); &#125;&#125;/** 具体观察者**/public class Subscriber implements Observer &#123; private String userName; private String userMail; public Subscriber(String userName, String userMail)&#123; this.userName = userName; this.userMail = userMail; &#125; @Override public void update(String state) &#123; System.out.println(userName + \"(\"+ userMail + \") got a new message:\" + state); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; JavaMessagePublisher javaMessagePublisher = new JavaMessagePublisher(); Subscriber userA = new Subscriber(\"zhangsan\", \"zhangsan@gmail.com\"); Subscriber userB = new Subscriber(\"lisi\", \"lisi@gmail.com\"); javaMessagePublisher.addSubscriber(userA); javaMessagePublisher.addSubscriber(userB); javaMessagePublisher.setState(\"jdk 1.8 publish!!!\"); PHPMessagePublisher phpMessagePublisher = new PHPMessagePublisher(); Subscriber userC = new Subscriber(\"zhaowu\", \"zhaowu@gmail.com\"); phpMessagePublisher.addSubscriber(userA); phpMessagePublisher.addSubscriber(userC); phpMessagePublisher.setState(\"php has a new version!!!\"); &#125;&#125;","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：迭代器模式（Iterator Pattern）","date":"2017-03-09T13:22:52.000Z","path":"2017/03/09/浅谈设计模式：迭代器模式（Iterator-Pattern）/","text":"什么是迭代器模式？ 官方解释： to access the elements of an aggregate object sequentially without exposing its underlying implementation 顺序地访问集合对象的元素并且不暴露它的内部实现 通俗解释：假设给定一个集合对象，定义一个与之相关联的Iterator（迭代器），该迭代器能够访问集合对象的内部元素，通过迭代的方法能够按照顺序依次访问集合对象的每一个元素。 为什么使用迭代器模式？ 它能让集合内部元素结构对于客户端透明的情况下遍历该集合。保证了封装性，透明性。 提供了一个统一的方法去访问你的数据对象（集合），并且你不需要知道数据对象的类型。 实用性很强，得到了广泛的应用，并且拓展性很强，容易自己进行拓展。 如何使用迭代器模式？UML图如下： 各个组件解释： Iterator：抽象迭代器，定义了迭代器最基本的接口。如：hasNext()表示是否该迭代是否还有下一个元素，next则是返回迭代的下一个元素。 Aggregate：抽象集合，定义了集合的基本操作接口。如：add()向该集合增加一个原色，remove()则表示删除某个元素。 ComcreteAggregate：具体数据集合类，定义了集合元素的结构，操作细节。同时在类内部定义了一个具体迭代器并提供一个能够返回迭代器对象的方法。 ConcreteIterator：具体迭代器，通常定义在聚合类的内部，以此来达到访问聚合类内部数据结构的目的，同时实现了迭代访问聚合类元素的方法。 使用范围： 当你想要在不暴露其内部表示的情况下访问一个对象集合 当你想要有多种遍历方式来遍历一个对象集合，如正序、倒序、跳表访问 应用举例：假设现在有一个学生对象集合类，客户端并不想关心其内部细节，只需要能遍历学生对象（或者学生对象的某些属性）即可。使用迭代器模式来实现这个需求。 1、定义迭代器以及集合的抽象接口。12345678interface Iterator&lt;T&gt; &#123; T next(); boolean hasNext();&#125;interface Collection&lt;T&gt; &#123; boolean add(T element); boolean remove(T element);&#125; 2、定义学生对象类，简明起见，不定义太多复杂属性 1234567891011121314151617181920public class Student &#123; private String id; private String name; public Student(String id, String name) &#123; this.id = id; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125;&#125; 3、实现具体学生对象聚合类，并在内部依赖定义具体迭代器。 12345678910111213141516171819202122232425262728293031323334public class StudentList implements Collection&lt;Student&gt; &#123; List&lt;Student&gt; elementList = new ArrayList&lt;&gt;(); @Override public void add(Student element) &#123; elementList.add(element); &#125; @Override public boolean remove(Student element) &#123; return elementList.remove(element); &#125; public Iterator&lt;Student&gt; createIterator()&#123; return new StudentIterator(elementList); &#125; //具体迭代器类 private class StudentIterator implements Iterator&lt;Student&gt; &#123; private List&lt;Student&gt; students; private int position; public StudentIterator(List&lt;Student&gt; students) &#123; this.students = students; this.position = 0; &#125; @Override public Student next() &#123; if(hasNext()) &#123; return students.get(position++); &#125; return null; &#125; @Override public boolean hasNext() &#123; return position &lt; students.size(); &#125; &#125;&#125; 4、使用客户端调用，此处mock一个测试数据，方便调用。 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; StudentList studentList = new StudentList(); studentList.add(new Student(\"001\", \"张三\")); studentList.add(new Student(\"002\", \"李四\")); studentList.add(new Student(\"004\", \"赵五\")); studentList.add(new Student(\"004\", \"钱六\")); Iterator&lt;Student&gt; iterator = studentList.createIterator(); while(iterator.hasNext())&#123; Student student = iterator.next(); System.out.println(student.getId() + student.getName()); &#125; &#125;&#125; 注：此处的抽象迭代器、抽象集合接口，均只是声明了最简单常用的方法，之际开发中可以根据需求增加各种各样的方法. 迭代器则可以根据具体的聚合，选择不同的遍历方式：正序、倒序、跳表等。而遍历的可以不是整个对象，或许你指向遍历对象的某个属性呢，如上例你指向要遍历学生的学号，或者说学号用得最勤快，那么你另外定义一个迭代方法nextId来遍历学生的学号呀。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：解释器模式（Interpreter Pattern）","date":"2017-03-08T14:51:56.000Z","path":"2017/03/08/浅谈设计模式：解释器模式（Interpreter-Pattern）/","text":"什么是解释器模式？ 官方解释： to define a representation of grammar of a given language, along with an interpreter that uses this representation to interpret sentences in the language。 定义一个给定语言的语法表达式，并用该表达式作为一个解释器来解释语言中的句子。 通俗解释：给定一种语言及相关语法，根据这些语法定义一个语法表达式的解释器，客户端可以使用这个解释器来解释这个语言中句子。 为什么使用解释器模式？ 语法表达式进行抽象封装，易于修改及拓展，当这个语言新增了某种特性，可以通过继承抽象表达式类来实现新的语言特性。 每一条语法都可以表示为一个表达式类，实现起来比较容易。 PS：该模式由于其结构特性，对于复杂语法很难维护，执行效率比较低，因此实际开发中几乎不适用这个模式，但是其本身的结构以及思想还是可以学习借鉴一下的。 如何使用解释器模式？UML图如下： 各个组件解释： AbstractExpression（抽象表达式）：声明一个抽象的解释操作interpreter，这个接口为所有具体表达式角色（抽象语法树中的节点）都要实现的。 TerminalExpression（终结表达式）：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 NonTerminalExpression（非终结表达式）：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。 Client（客户端）：使用解释器的角色。 Context（上下文）：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用一个映射（Map）来充当环境角色就足够了。 应用实例：有这么一个简单的需求，给予一个字符，让你判断是否是数字字符（‘0’-‘9’），可以这么实现： 1、定义一个抽象表达式 123interface AbstractExpression &#123; boolean interpret(Character character);&#125; 2、定义终结表达式，即直接判断字符是否是数字字符 1234567public class TerminalExpression implements AbstractExpression &#123; @Override public boolean interpret(Character character) &#123; //是否是数字字符 return character.isDigit(character); &#125;&#125; 3、定义简单的非终结表达式，and 、not 、or 123456789101112131415161718192021222324252627282930313233343536373839404142public class AndExpression implements AbstractExpression &#123; private AbstractExpression leftExpression; private AbstractExpression rightExpression; public AndExpression(AbstractExpression leftExpression, AbstractExpression rightExpression) &#123; this.leftExpression = leftExpression; this.rightExpression = rightExpression; &#125; @Override public boolean interpret(Character character) &#123; return leftExpression.interpret(character) &amp;&amp; rightExpression.interpret(character); &#125;&#125;public class NotExpression implements AbstractExpression &#123; private AbstractExpression expression; public NotExpression(AbstractExpression expression) &#123; this.expression = expression; &#125; @Override public boolean interpret(Character character) &#123; return !expression.interpret(character); &#125;&#125;public class OrExpression implements AbstractExpression &#123; private AbstractExpression leftExpression; private AbstractExpression rightExpression; public OrExpression(AbstractExpression leftExpression, AbstractExpression rightExpression) &#123; this.leftExpression = leftExpression; this.rightExpression = rightExpression; &#125; @Override public boolean interpret(Character character) &#123; return leftExpression.interpret(character) || rightExpression.interpret(character); &#125;&#125; 4、客户端使用，这里由于相对简单，不需要使用context组件： 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Character digitCharacter = new Character('1'); Character notdigitCharacter = new Character('l'); AbstractExpression terminalExpression = new TerminalExpression(); AbstractExpression notExpression = new NotExpression(terminalExpression); AbstractExpression andExpression = new AndExpression(terminalExpression, notExpression); AbstractExpression orExpression = new OrExpression(terminalExpression, notExpression); System.out.println(andExpression.interpret(digitCharacter)); System.out.println(andExpression.interpret(notdigitCharacter)); System.out.println(orExpression.interpret(digitCharacter)); System.out.println(orExpression.interpret(notdigitCharacter)); &#125;&#125;","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：命令模式（Command Pattern）","date":"2017-03-08T14:38:10.000Z","path":"2017/03/08/浅谈设计模式：命令模式（Command-Pattern）/","text":"什么是命令模式？ 官方解释： encapsulate a request under an object as a command and pass it to invoker object. Invoker object looks for the appropriate objectwhich can handle this command and pass the command to the corresponding object and that object executes the command。 （封装一个请求对象作为一个命令并传递给调用器（命令发送者）对象。调用期对象寻找合适的能处理这条命令的对象并传递这条命令到应答（命令接受者）对象中，接着该对象执行这条命令.） 通俗解释：将一条命令封装成一个（请求）对象，定义一个命令调用器（发送者），一个命令执行器（接受者），将命令与命令接受者进行关联，并且由命令发送者来承载这条命令（一个命令调用器可承载多条命令），当客户端需要下达某个命令时，通过命令发送者调用相关命令即可。 为什么使用命令模式？ 将命令抽象封装起来，使得命令易修改，可拓展，高复用性。拓展时并不需要动旧命令的代码。可讲两个简单的命令组合复用成一个新的命令。 将命令与命令具体的操作（接受者进行）分离，使得命令并不需要关心命令具体的操作，仅需确定命令的接受者即可。 将命令交由命令发送者（命令调用期）进行相关联，使得客户端并不需要关心命令的任何细节，仅需要使用命令发送者出发某个命令即可。 如何使用命令模式？命令模式的UML图如下： 各个组件解释说明： Command（抽象命令）：命令的抽象体，定义一个命令执行操作的接口。 Invoker（命令调用器）：命令的调用器（发送者），内聚了一个或多个命令对象，由客户端调用某个命令。 ConcreteCommand（具体命令）：具体的某个命令，关联了一个命令接受者，并借此实现了命令执行操作（由关联的命令接受者决定具体操作）的方法。 Receiver（命令接受者）：定义了一系列命令动作的具体响应操作，与某些命令相关联。 Client（客户端）：出发命令的客户端，在此之前需要将各个关联关系、内聚关系确定。注：此处也可再进行一次包装，将确定各个组件之间的关系的代码包装成一个第三方类，并由客户端调用。 命令模式使用范围： 当一个场景中具有请求–&gt;响应的功能，并且请求种类不少，希望响应功能对客户端透明。 当一个场景中，需要根据请求操作参数对象执行某些操作。 当你希望一个请求对象的创建和执行不在同一个时间。即命令创建后不用马上使用，在需要的时候使用。 当一个场景中你需要支持回滚、恢复、记录等功能时。 应用实例：现在我们有这么一个场景，还记得之前Builder模式的例子吗，我们构造出寒冰射手这个Role之后，我们要发出命令来让英雄释放技能呀，我们可以这么做： 1、我们先抽象出一个Command接口，定义一个执行命令的接口。接着再抽象出Role接口，定义了QWER四个技能的释放方法接口。并用HanBingRole实现这一接口及技能释放方法。 123456789101112131415161718192021222324252627interface Command &#123; public void excute();&#125;public interface Role &#123; void QSkill(); void WSkill(); void ESkill(); void RSkill();&#125;public class HanBingRole implements Role &#123; @Override public void QSkill() &#123; System.out.println(\"冰霜射击！！！\"); &#125; @Override public void WSkill() &#123; System.out.println(\"万箭齐发！！！\"); &#125; @Override public void ESkill() &#123; System.out.println(\"鹰击长空！！！\"); &#125; @Override public void RSkill() &#123; System.out.println(\"魔法水晶箭\"); &#125;&#125; 2、抽象完毕，那么我们需要定义具体的命令类，并与命令接受者（Role）相依赖，让接受者自己来执行命令的具体操作（role.XSkill()）。 12345678910111213141516171819202122232425262728293031323334353637383940public class QSkillCommand implements Command &#123; private Role role; public QSkillCommand(Role role) &#123; this.role = role; &#125; @Override public void excute() &#123; role.QSkill(); &#125;&#125;public class WSkillCommand implements Command &#123; private Role role; public WSkillCommand(Role role) &#123; this.role = role; &#125; @Override public void excute() &#123; role.WSkill(); &#125;&#125;public class ESkillCommand implements Command &#123; private Role role; public QSkillCommand(Role role) &#123; this.role = role; &#125; @Override public void excute() &#123; role.ESkill(); &#125;&#125;public class RSkillCommand implements Command &#123; private Role role; public QSkillCommand(Role role) &#123; this.role = role; &#125; @Override public void excute() &#123; role.RSkill(); &#125;&#125; 3、具体命令和接收者都定义好了，接下来我们需要一个命令发送者（Invoker），由于具体命令较多，此处可定义一个技能类型枚举SkillType（QWER），并在Invoker定义一个map，让客户端决定技能类型与具体命令的关联。 123456789101112131415161718192021222324252627282930313233343536373839enum SkillType &#123; QSKILL,WSKILL,ESKILL,RSKILL&#125;public class SKillInvoker &#123; private Map&lt;SkillType, Command&gt; commandMap; SKillInvoker(Map&lt;SkillType, Command&gt; commandMap) &#123; this.commandMap = commandMap; &#125; public void castQSkill()&#123; commandMap.get(SkillType.QSKILL).excute(); &#125; public void castWSkill()&#123; commandMap.get(SkillType.WSKILL).excute(); &#125; public void castESkill()&#123; commandMap.get(SkillType.ESKILL).excute(); &#125; public void castRSkill()&#123; commandMap.get(SkillType.RSKILL).excute(); &#125;&#125;public class client &#123; public static void main(String[] agrs) &#123; HanBingRole hanBingRole = new HanBingRole(); Map&lt;SkillType, Command&gt; commandMap = new HashMap&lt;&gt;(); commandMap.put(SkillType.QSKILL, new QSkillCommand(hanBingRole)); commandMap.put(SkillType.WSKILL, new WSkillCommand(hanBingRole)); commandMap.put(SkillType.ESKILL, new ESkillCommand(hanBingRole)); commandMap.put(SkillType.RSKILL, new RSkillCommand(hanBingRole)); SKillInvoker sKillInvoker = new SKillInvoker(commandMap); sKillInvoker.castQSkill(); sKillInvoker.castWSkill(); sKillInvoker.castESkill(); sKillInvoker.castRSkill(); &#125;&#125; 此处HanBingRole的其他属性以及实例化方式我为简明起见做了简化，并没有使用Builder模式。 实际开发中,HanBingRole可能是用其他的创建型模式进行实例化，创建型模式的具体用法可阅读我的前几篇文章。 另外，此处技能类型与命令的映射也是用了最直接的方法，实际开发中，可能使用配置方式或其他易修改可拓展的方式来实现。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：责任链模式（Chain Of Responsibility）","date":"2017-03-08T14:29:45.000Z","path":"2017/03/08/浅谈设计模式：责任链模式（Chain-Of-Responsibility）/","text":"什么是责任链模式？ 官方解释： avoid coupling the sender of a request to its receiver by giving multiple objects a chance to handle the request。 (使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。) 通俗解释：一个执行命令可能被多个对象处理，为避免发送命令者和接收（处理）命令者之间具有比较复杂的关联，将这多个处理的对象当作一条责任链中的一个个结点，并使请求命令经过该责任链，这些结点都有机会处理请求。 为什么使用责任链模式？ 发送命令者与接受命令者解耦，若不加以包装，可能一种命令要对应一种处理命令的对象，这样一发送者与接收命令者之间关联变得复杂，形成了强耦合关系。这对与系统的拓展并没有好处。将命令处理对象拼接成一条处理命令的责任链，使得发送者与接受者形成弱关联，降低耦合性，易于拓展。 命令处理对象之间的链接通过继承者（successor）来实现，使得节点的顺序可灵活变化，并不需要固定一个顺序。 当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。 如何使用责任链模式？责任链模式的UML图如下： 各个组件解释： Client：命令的发送者。 Handler：抽象的命令处理器，定义了处理命令的抽象接口，内聚了一个Handler作为继承者（Successor）。 ConcreteHandler：具体的命令处理器，实现了处理命令的方法，并确定了当某个命令并不需要自己处理时，下一个处理该命令的继承者是谁。 使用范围： 多个对象可以处理一个请求 命令发送者与接受者之间的关系不想明确指定时，即命令对象希望被发送到一组命令处理器中而并不显示指定其接收器 处理某个指令的对象必须动态指定 纯与不纯责任链： 有一种说法，纯的责任链的命令处理节点只需要做到：处理该命令并返回、不处理该命令并传递。 即命令可能传递到应该处理的那个节点后中断传递。 不纯的责任链的命令处理节点则是这样：处理该命令并传递、不处理该命令并传递。 即命令一定会传递完整条责任链，其中的所有节点都有可能对该命令进行响应并处理。可能一个节点处理，也可能多个节点处理。Servlet的Filter便是采用了这种设计结构。 个人认为，并没有所谓纯与不纯之说，主要看你需要哪一种实现方案，说到底责任链仅仅是提供一个命令处理的包装，使得代码更加整洁，系统更加容易拓展。 应用实例：现在我们有这么一个需求，我想实现一个文本解析的功能，文件File充当命令，不同后缀格式的文件需要用不同的解析器（接受者）进行解析，那么我们可以这样： 1、定义一个抽象的解析器类，实现了公有的方法，以及声明了解析文件的抽象方法。 123456789101112131415161718192021222324public abstract class Parser &#123; private Parser successor; protected String fomat; public void transfer(File file) &#123; if (getSuccessor() != null) &#123; getSuccessor().parse(file); &#125; else &#123; System.out.println(\"不能找到解析该文本的相关处理器\"); &#125; &#125; public abstract void parse(File file); protected boolean canParseFile(File file) &#123; return (file != null) &amp;&amp; (file.getName().endsWith(this.fomat)); &#125; public void setFomat(String fomat) &#123; this.fomat = fomat; &#125; public Parser getSuccessor() &#123; return successor; &#125; public void setSuccessor(Parser successor) &#123; this.successor = successor; &#125;&#125; 2、定义具体的解析器， 当文件属于自身解析的范畴时，进行解析，否则传递给继承者。 1234567891011121314public class TextParser extends Parser &#123; public TextParser(Parser successor) &#123; setFomat(\"txt\"); setSuccessor(successor); &#125; @Override public void parse(File file) &#123; if (canParseFile(file)) &#123; System.out.println(file.getName() + \"文本文件解析成功\"); &#125; else &#123; super.transfer(file); &#125; &#125;&#125; 12345678910111213public class XmlParser extends Parser &#123; public XmlParser() &#123; setFomat(\"xml\"); &#125; @Override public void parse(File file) &#123; if (canParseFile(file)) &#123; System.out.println(file.getName() + \"XML文件解析成功\"); &#125; else &#123; super.transfer(file); &#125; &#125;&#125; 3、在客户端中定义责任链中的解析器的前后顺序。此处简明起见为：Text-&gt;Xml。1234567public class client &#123; public static void main(String[] args) &#123; XmlParser xmlParser = new XmlParser(); TextParser textParser = new TextParser(xmlParser); textParser.parse(new File(\"test.xml\")); &#125;&#125; 此处可拓展地方为： 可灵活增加解析器 继承者的初始化可不在构造方法中而使用setter方法 根据需求可将本结构改为一个文件解析多重文本格式的功能，即如上所说的“不纯”的责任链，具体细节各位可以自己研究一下。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：单例模式（Singleton）","date":"2017-03-08T13:55:05.000Z","path":"2017/03/08/浅谈设计模式：单例模式（Singleton）/","text":"什么是单例模式？ 一个类有且仅有一个实例，由系统自行实例化并通过一个全局访问点向整个系统提供。 为什么使用单例模式？ 节省内存，不需要在每次使用的时候都实例化一个对象出来 一个实例全局提供重复利用 某些环境下保证类有且只有一个实例非常重要，如：windows下任务管理器。 如何使用单例模式？单例模式的写法千奇百怪，各种各种的写法都有，最终逃不过以下三个要点： 有且仅有一个实例 无需手动创建，系统自行实例化 通过唯一一个全局访问点向整个系统提供使用 此外不同环境下可能还会有不同要求：保证线程安全、保证序列化、反序列化时不产生多个实例、 多个类加载器加载时产生多个实例等等。 第一种实现：1234567891011public class Singleton &#123; private static Singleton singleton = null; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; return singleton ; &#125;&#125; 这一种实现Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。 第二种实现：12345678public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return singleton ; &#125;&#125; 这一种单例的实例化基于classloader机制，避免了多线程安全的方式，同时也不需要在实例每一次使用时判断是否已经实例化，属于最常用的方式。类似实现还可以使用静态块来进行单例的实例化，不要累述。 第三种实现：123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder. INSTANCE; &#125;&#125; 这一种实现Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。 第四种实现：1234public enum Singleton&#123; SINGLETON; public void doWhatever()&#123;&#125;;&#125; 这一种实现使用枚举来实现，能避免多线程同步问题，还能防止反序列化重复创建对象的问题，但由于枚举是在jdk1.5才加入的新特性，因此目前还很少看到有人在实际项目中使用。 第五种实现：1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton. class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton ; &#125;&#125; 已经被摒弃使用的一种写法，具体可戳….http://blog.csdn.net/kufeiyun/article/details/6166673 此外，在阅读uncle bob 的一篇关于单例和“仅创建一个实例”的文章中，他提供了另一种可行的方式：123456789101112public class Singleton &#123; private Singleton()&#123;&#125; public static NonSingleton nonSingleton = new NonSingleton( new Singleton());&#125;public class NonSingleton &#123; public NonSingleton(Singleton singleton) &#123; assert (singleton != null); &#125; public void doWhatever()&#123; &#125;&#125; 这一种实现主要是因为uncle bob 认为单例模式自身违背了SRP（单一职责原则）即一个类只做一件事的原则，而他的这种实现即是将单例实例化、以及单例做的事情分割开来。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：原型模式（Prototype Pattern）","date":"2017-03-08T13:34:16.000Z","path":"2017/03/08/浅谈设计模式：原型模式（Prototype-Pattern）/","text":"什么是原型模式？ 官方解释： cloning of an existing object instead of creating new one and can also be customized as per the requirement.(克隆一个现有对象来代替新建一个对象，并且可以按定制要求克隆。) 通俗解释：通过新建一个原型对象（该对象实现一个具有克隆接口的抽象类、接口）指明要创建的类型，调用对象自身的克隆接口创建出更多的同类型对象。 为什么使用原型模式？ 简化对象创建的过程，利用现有对象直接调用克隆方法实现对象的创建。 降低子类的需求。 客户获取对象时不需要知道哪一个类型的对象会呗创建。 可在运行时创建、销毁对象。 如何使用原型模式？原型模式UML图如下： 调用方：在已有一个原型对象的前提下，调用原型对象的克隆方法来获取（大量）同类型对象。 原型接口：定义一个clone接口的抽象类（接口）。 具体原型类：每一个原型类都要实现（继承）该接口，并实现接口的clone（克隆）方法。这里的clone必须是深克隆的，即在一些具有引用型对象（java的引用、c/c++的指针），必须将引用型对象所指的成员全部复制一遍，而不是仅仅将引用的地址复制一遍。 这里讲到了深复制，为了让不懂这个概念的同学了解一下，那么就来科普一下深复制和浅复制的概念。 浅复制：克隆类对象的时候，在类具有引用型成员对象时，仅仅将对象类中的引用性对象的地址复制一份到新的对象去，所以此时被克隆出来新的对象的应用型成员对象指向的还是和原来的对象一样。 深复制：克隆类对象的时候，将类内部的引用型成员对象指向的成员也挨个复制一边赋值到新建的类对象中，并且此过程可嵌套，因为引用型成员对象指向的成员也可能具有引用型成员对象，因此在实现克隆的时候，需要考虑克隆的对象是否会出现这个嵌套的过程，再三注意，若嵌套过深造成克隆的性能过差，可考虑放弃使用原型模式（这种情况一般很少出现）。 原型模式使用场景： 当类需要在运行时进行实例化。 当创建一个对象过于复杂和昂贵。 当你想保持应用中类数量最小。 当客户端（调用方）不想知道类的创建和表示。 应用实例：听说过纳米机器人吗？现在有一种这样的纳米机器人，他们只要有足够的能量就能无限自我复制，在许多领域都有强大的作用，那么我们现在来抽象定义一个纳米机器人的原型。 首先肯定是：Prototype抽象类（接口）、该接口具有clone方法。在java中，Object对象具有clone接口，这个接口是声明为protected的，java本身所有类Object的子类，但是需要实现Cloneable接口后才能调用clone方法。因此，在java中Prototype这个接口可直接省略，直接用具体原型对象类实现Cloneable接口即可。题外话，这里的clone方法还是声明为native的，java中该关键字的意思是该声明的方法的实现使用非java代码实现的，详细细节可自行搜索哈。 接着定义具体的原型对象类（naroRobot）并实现原型接口（此处是Cloneable），重写clone方法，克隆的实现必须是深复制的，这里不纠结与深浅复制的实现，之后会有相关详细的介绍。 1234567891011121314public class NaroRobot implements Cloneable &#123; private String id; private String name; //……各种属性，为引用型成员时需要进行深复制 public NaroRobot(String id, String name) &#123; this.id = id; this.name = name; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; //此处假设该原型类没有引用型对象。 return super.clone(); &#125;&#125; 最后是在现有一个naroRobot的情况下，调用对象的clone方法实现大规模纳米机器人的创建12345678910111213public class Client &#123; public static void main(String[] args) &#123; NaroRobot naroRobot = new NaroRobot(\"007\", \"robot\"); List&lt;NaroRobot&gt; naroRobotList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; ++i) &#123; try &#123; naroRobotList.add(naroRobot.clone()); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; PS：此处的原型接口也可不省略，在有多个同类的原型对象类时，可增加一个抽象类实现Cloneable接口，然后具体原型类再继承该类即可。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：建造者模式（Builder Pattern）","date":"2017-03-08T13:21:25.000Z","path":"2017/03/08/浅谈设计模式：建造者模式（Builder-Pattern）/","text":"什么是建造者模式? 官方解释： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 通俗解释：一个产品抽象成的类可能属性会很多并且这些属性很难在一个简单的（构造）方法中全部初始化完毕，或者说全部构建完毕，这个时候使用一个抽象构造器（Builder），将这类产品的构造属性抽象成几组构建方法，不同的建造者（构建器）可以有不同的组织构建实现，最终在一个流程总控的类（Director）中控制流程化调用Builder的构建方法，这样的创建型逻辑便为建造者模式。 为什么使用建造者模式？ 造者模式与工厂模式很相似，同样具有很好的封装性，客户端不需要知道产品的内部组成细节。 Builder（建造者）相对独立，对外部其他的Builder并没有依赖，因此扩展性非常好。 对象建造过程中，各个流程责任细分，逐步细化，局部细节的变化对于其他模块不会产生什么影响。 如何使用建造者模式？建造者模式的常用UML图如下： 各个组件的定义如下： Product（产品）：一个结构复杂的对象，实例化流程比较复杂，具有较多的代码量。实际项目中，该角色也可以是抽象产品，衍生出各种复杂的子类对象。 Builder（抽象建造者）：为创建一个Product而抽象出流程各个步骤的抽象接口。主要用此接口来进行扩展出各式各样的产品建造者。 ConcreteBuilder（具体建造者）：实现Builder的抽象接口，是一个具体的产品建造者，一般会有两个以上的方法，一个或一个以上接口用来实例化产品，一个用来返回实例化后的产品对象。 Director（导演类）：内聚一个Builder接口对象，产品建造的流程总控，对建造者的各个实例步骤方法进行顺序调用，并且利用多态实现不同复杂对象的实例化。一般不与产品类发生直接依赖的关系，仅依赖于抽象层次下的Builder接口。是与客户端（调用方）直接交互的组件。 适用范围： 需要生成的产品对象内部具有复杂的结构。 需要生成的产品对象内部属性相互依赖，若使用常规工厂方法实例化，可能导致系统具有较高的耦合性，因此可采用建造者模式强制内部属性的生成顺序。 一个复杂对象的使用工厂模式的实例化算法较为稳定，而需求的变化，经常需要对该对象的局部细节进行修改，此时建造者模式的流程化构建明显满足需求。 应用例子： 就说说英雄联盟这个游戏吧，游戏的每一个召唤师英雄的属性都是极为复杂的，那么在此简化一下，我想要构建每一个英雄的q、w、e、r四个技能，其他暂时忽视，此时在builder可抽象四个构建这四个技能的方法，以及一个获取最终产品的方法，然后我们先实现builder接口定义一下寒冰射手的英雄Builder（果然对寒冰情有独钟）,接着定义一个Director类，内聚一个Builder接口，定义一下construct方法，方法体内依次调用builder的四个技能构建接口，然后返回构建完召唤师英雄类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** 抽象builder，抽象英雄的基本构造**/public abstract class Builder &#123; public abstract void buildQSkill(); public abstract void buildWSkill(); public abstract void buildESkill(); public abstract void buildRSkill(); public abstract GameRole getRole();&#125;/** 具体builder，寒冰射手艾希的具体builder**/public class HanBingBuilder extends Builder &#123; private GameRole hangBingRole; public HanBingBuilder() &#123; this.hangBingRole = new GameRole(); &#125; @Override public void buildQSkill() &#123; hangBingRole.setqSkill(\"冰霜射击\"); &#125; @Override public void buildWSkill() &#123; hangBingRole.setwSkill(\"万箭齐发\"); &#125; @Override public void buildESkill() &#123; hangBingRole.seteSkill(\"鹰击长空\"); &#125; @Override public void buildRSkill() &#123; hangBingRole.setrSkill(\"魔法水晶箭\"); &#125; @Override public GameRole getRole() &#123; return hangBingRole; &#125;&#125;/** 产品，即游戏英雄角色**/public class GameRole &#123; private String qSkill; private String wSkill; private String eSkill; private String rSkill; public void setqSkill(String qSkill) &#123; this.qSkill = qSkill; &#125; public void setwSkill(String wSkill) &#123; this.wSkill = wSkill; &#125; public void seteSkill(String eSkill) &#123; this.eSkill = eSkill; &#125; public void setrSkill(String rSkill) &#123; this.rSkill = rSkill; &#125; public String getqSkill() &#123; return qSkill; &#125; public String getwSkill() &#123; return wSkill; &#125; public String geteSkill() &#123; return eSkill; &#125; public String getrSkill() &#123; return rSkill; &#125;&#125;/** 导演类**/public class Director &#123; Builder roleBuilder = null; public void setRoleBuilder(Builder roleBuilder) &#123; this.roleBuilder = roleBuilder; &#125; public GameRole construct() &#123; roleBuilder.buildQSkill(); roleBuilder.buildWSkill(); roleBuilder.buildESkill(); roleBuilder.buildRSkill(); return roleBuilder.getRole(); &#125;&#125;/** 客户端测试**/public class ClientTest &#123; public static void main(String[] args)&#123; Builder hanBingBuilder = new HanBingBuilder(); Director director = new Director(); director.setRoleBuilder(hanBingBuilder); GameRole hanBingRole = director.construct(); System.out.println(\"q技能是:\" + hanBingRole.getqSkill()); &#125;&#125; 此后，要想新增一个新的召唤师英雄，比如光辉女郎，仅需实现Builder接口定义四个技能构建方法的实现即可，对于其他组件弱依赖，变更成本很低。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：抽象工厂模式（Abstract Factory Pattern）","date":"2017-03-08T13:07:58.000Z","path":"2017/03/08/浅谈设计模式：抽象工厂模式（Abstract-Factory-Pattern）/","text":"什么是抽象工厂模式？ 官方解释： define an interface or abstract class for creating families of related (or dependent) objects but without specifying their concrete sub-classes。 （定义一个接口或抽象类用于创建一系列相关（或依赖）的对象并且不指定他们具体的子类） 通俗解释：普通工厂即具体的工厂生产相对应的一种具体产品，一般情况下具有一个或一组生产产品的方法，具有比较强的单一性，而抽象工厂则是希望一个工厂生产多种不同等级结构的产品，并且具有一个或多个工厂生产同个产品族不同等级结构的产品。 例如： 奶茶店生产：小杯奶茶、大杯奶茶（同一个产品族、不同的产品等级结构（小、大））; 咖啡店生产：小杯咖啡、大杯咖啡（同一个咖啡产品族，不同的产品等级结构（小、大）） 两个工厂之间产品不一样，但是等级结构相似或者说相互依赖，此时便适合使用抽象工厂模式。 为什么使用抽象工厂模式？ 当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。 工厂模式具有的优点，抽象工厂都具有…. 如何使用抽象工厂模式？先说说抽象工厂各个成员的定义： 产品等级结构：如上述，小杯奶茶可抽象为“小杯饮品”这个产品等级结构，同理中杯奶茶则属于“中杯饮品”这个产品等级结构。又或者大众生产的奥迪Q3可抽象为“乘用车”、宝马生产的x1也可抽象为“乘用车”，两者属于同一个产品等级结构。 产品族：指同一个工厂下生产的不同产品等级结构的产品，如奶茶店生产的“小杯饮品”奶茶、“中杯饮品”奶茶。 抽象工厂(AbstractFactory)：最顶层抽象，定义了一个组创建同一个产品族产品的方法。 具体工厂(ConcreteFactory)：具体工厂，实现创建工厂内不同产品等级结构的产品的方法。 抽象产品(AbstractProduct)：定义一个不同产品族但具有相同产品等级结构的产品。 具体产品(ConcreteProduct)：具体产品，实现了各个产品族在该产品等级结构下的产品。 如上图所述，Aproduct、BProduct抽象了同个产品等级结构的产品，AProductA、AProductB属于同一个工厂生产的产品，即具体工厂ConcreteFactory生产的产品。抽象工厂AbstractFactory定义了一组创建XXProductA、XXProductB产品族的方法，ConcreteFactory、AnotherConcreteFactory则实现各自工厂内该等级结构下的产品的创建方法。 实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/**抽象工厂，创建饮料工厂**/interface DrinkFactory &#123; SmallDrink createSmallDrink(); MiddleDrink createMiddleDrink(); LargeDrink createLargeDrink();&#125;/** 具体工厂，咖啡饮料工厂**/public class CafeFactory implements DrinkFactory &#123; @Override public SmallDrink createSmallDrink() &#123; return new SmallCafeDrink(); &#125; @Override public MiddleDrink createMiddleDrink() &#123; return new MiddleCafeDrink(); &#125; @Override public LargeDrink createLargeDrink() &#123; return new LargeCafeDrink(); &#125;&#125;/** 具体工厂，奶茶饮料工厂**/public class TeaFactory implements DrinkFactory &#123; @Override public SmallDrink createSmallDrink() &#123; return new SmallTeaDrink(); &#125; @Override public MiddleDrink createMiddleDrink() &#123; return new MiddleTeaDrink(); &#125; @Override public LargeDrink createLargeDrink() &#123; return new LargeTeaDrink(); &#125;&#125;/** 抽象产品，小杯饮料**/public class SmallDrink &#123;&#125;/** 具体产品，小杯咖啡**/public class SmallCafeDrink extends SmallDrink &#123; public SmallCafeDrink() &#123; System.out.println(\"小杯咖啡\"); &#125;&#125;/** 具体产品。小杯奶茶**/public class SmallTeaDrink extends SmallDrink &#123; public SmallTeaDrink() &#123; System.out.println(\"小杯奶茶\"); &#125;&#125;/** 抽象产品，中杯饮料**/public class MiddleDrink &#123;&#125;/** 具体产品，中杯咖啡**/public class MiddleCafeDrink extends MiddleDrink &#123; public MiddleCafeDrink() &#123; System.out.println(\"中杯咖啡\"); &#125;&#125;/** 具体产品，中杯奶茶**/public class MiddleTeaDrink extends MiddleDrink &#123; public MiddleTeaDrink() &#123; System.out.println(\"中杯奶茶\"); &#125;&#125;/** 抽象产品，大杯饮料**/public class LargeDrink &#123;&#125;/** 具体产品，大杯咖啡**/public class LargeCafeDrink extends LargeDrink &#123; public LargeCafeDrink() &#123; System.out.println(\"大杯咖啡\"); &#125;&#125;/** 具体产品，大杯奶茶**/public class LargeTeaDrink extends LargeDrink &#123; public LargeTeaDrink() &#123; System.out.println(\"大杯奶茶\"); &#125;&#125;/** 测试客户端**/public class ClientTest &#123; public void static main(String[] args) &#123; DrinkFactory cafeFactory = new CafeFactory(); SmallDrink smallCafe = cafeFactory.createSmallDrink(); MiddleDrink middleCafe = cafeFactory.createMiddleDrink(); LargeDrink largeCafe = cafeFactory.createLargeDrink(); DrinkFactory teaFactory = new TeaFactory(); SmallDrink smallTea = teaFactory.createSmallDrink(); MiddleDrink middleTea = teaFactory.createMiddleDrink(); LargeDrink largeTea = teaFactory.createLargeDrink(); &#125;&#125;","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"浅谈设计模式：工厂模式（Factory Pattern）","date":"2017-03-08T13:01:33.000Z","path":"2017/03/08/浅谈设计模式：工厂模式（Factory-Pattern）/","text":"什么是工厂模式？ 官方解释： define an interface or abstract class for creating an object but let the subclasses decide which class to instantiate (定义一个创建对象的接口或者抽象类，但让子类去决定哪一个类去实例化) 通俗解释：当存在大量的公共的创建对象接口时，将其抽象定义一个接口或者出抽象类来创建对象，并由其子类来决定创建的是哪一个对象。 为什么使用工厂模式？ 不对客户端暴露创建对象的实例化逻辑。在实际的项目开发中，类的实例化有时候会是很复杂、很多样的，工厂模式将类的实例化逻辑封装起来，使其对于客户端（调用者）是透明的，只需要依赖相关的工厂类来创建需要的类即可。 通过一个公共的接口去创建新的对象，并且这个创建的对象是延迟到子类去决定的。 由于不必在代码中关联应用特定的类，促进了松耦合。同样的，特定的类的实例化逻辑往往也是很复杂的，可能需要想实例化相关联的类带进客户端中，使得客户端变得不纯粹，产生变更时造成的影响面更大，而使用工厂模式，即使是你想要创建的类的具体实现（或实例化逻辑）发生变化时，对于客户端来说也是透明的，使得系统更加稳定。 如何使用工厂模式？工厂类可以说是实际开发中使用得最多的模式，那么什么时候该使用咧？ When a class doesn’t know what sub-classes will be required to create.（当一个类不知道将要创建哪一个子类时。） When a class wants that its sub-classes specify the objects to be created.（当一个类希望其子类指定要创建的对象时） When the parent classes choose the creation of objects to its sub-classes.（当父类选择创建子类的对象时） 通俗点就是： 当一种产品具有多个产品簇时 当产品类的实例化逻辑不希望被客户端依赖时 当一个系统的多个类可以被抽象为一个共同的特性并能被抽象为一个创建对象的接口或抽象类时。 说到底，就是当你希望你的系统希望具有松耦合、少依赖的特性，并且当前的设计环境符合工厂的设计模型时，均可使用抽象工厂。但是，这里需要注意，当一个类的实例化逻辑非常简单，对于客户端依赖微乎其微以至于变更不产生相互影响或影响甚少时，可直接使用new进行实例化。 具体应用实例：假如我现在有一个产品A，产品A的实例化需要有两个前置条件（S、Y）,于是呼你可能这样做： 123456789101112131415161718 public class ProductA &#123; public ProductA(CoditionS s, CoditionY y)&#123; //initialize System. out .println(\"成功生产产品A\" ); &#125;&#125;public class CoditionS &#123;&#125;public class CoditionY &#123;&#125;public class TestFactory &#123; public static void main(String[] args)&#123; //这里是客户端，即调用方 CoditionS s = new ConditionS(); CoditionY y = new ConditionY(); ProductA a = new ProductA(s, y); &#125;&#125; 这里很明显就是客户端已经将产品A所依赖的ConditionS、ConditionY给直接依赖进来了，事实上这两个条件和客户端并没有半毛钱关系，只是与产品A有关系而已，因此这样做的话，严重违反迪米特法则（Law of Rule）即只与直接朋友联系，不要和“陌生人”联系,而且你想想看，如果产品需要的条件不只两个呢，如果产品依赖的条件其中有一两个Condition实例化的时候可能又会依赖到其他的类或变量呢，这是一个恶性循环的依赖过程，这对于一个系统应用来说是一个噩梦，也是一个程序员不应该犯的错误。 工厂模式来实现：12345678910111213141516171819202122232425public class Product &#123; //产品抽象出来的公共属性&#125;public class ProductA extends Product &#123; private ConditionS s; private ConditionY y; public ProductA(CoditionS s, CoditionY y)&#123; //initialize this .s = s; this .y = y; System.out.println( \"成功生产产品A\" ); &#125; &#125;public class ProductAFactory &#123; public Product createProductA()&#123; return new ProductA( new CondistionS(), new ConditionY()); &#125;&#125;public class TestFactory &#123; public static void main(String[] args)&#123; //这里是客户端，即调用方 ProductAFactory productAFactory = new ProductAFactory(); Product productA = productAFactory.createProductA(); &#125;&#125; 这个时候，客户端的耦合度明显减少，仅依赖与工厂，对于工厂如何生产产品A的具体逻辑并不关心，并且这个时候整个框架看起来很容易扩展，假设客户端还需要一个属于这个产品族的产品B，这个时候产品B的实例化逻辑再复杂，对于客户端来说也是毫无关系的，它仅仅需要使用工厂来调研那个创建产品B的方法就行，至于具体的创建逻辑，则交给工厂去解决。","tags":[{"name":"设计","slug":"设计","permalink":"http://qgxiaojin.com/tags/设计/"},{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qgxiaojin.com/tags/设计模式/"}]},{"title":"面向对象设计原则：迪米特法则（Law of Demeter）","date":"2017-03-07T15:28:51.000Z","path":"2017/03/07/面向对象设计原则：迪米特法则（Law-of-Demeter）/","text":"什么是迪米特法则？ 官方解释：一个对象应当对其他对象有尽可能少的了解。 通俗解释：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。 为什么遵循迪米特法则？ 当一个类与其他类之间依赖关系越多，耦合度越大时，类发生变化将会导致影响面越大、越广。而遵循迪米特法则就是为了尽量降低类与类之间的耦合度，什么是耦合度呢？就是一个类与其他类之间的联系、依赖程度。当一个类对其他类的依赖很少，变更所带来的影响面很小，自身功能模块具有独立性的时候，这个类就是一个低耦合、高内聚的优秀类。 这样的类当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 如何遵循迪米特法则？ 迪米特法则又叫最少知识原则，定义：不要和“陌生人”说话，只与你的直接朋友通信联系。朋友的定义：对象本身、类方法的（输入输出）参数、类成员。而出现在局部变量中的类就不是直接的朋友，即“陌生人”。 迪米特法则要求我们：在设计系统时，尽量减少对象之间的联系、交互、依赖。因为两个对象之间若不相互依赖、联系，那么这两个对象就不会发生任何相互作用，如果一定要发生联系的话，可以借用第三方进行转发调用（可参考门面模式Facade）。 个人感受：迪米特法则和其他的几大原则也是有紧密的联系的，单一职责原则（一个类只做一件事）减少了与其他对象依赖的可能性，依赖倒置原则（尽量依赖抽象层次高的类、接口）则减少了依赖对像后发生变更的影响面，接口隔离原则（客户端不应该依赖它不需要的接口）同样的减少了与其他对象产生联系的可能性、提升了类的内聚。等等诸如此类，个人感觉，优秀的、经验证正确的设计原则之间都是有共同性了，遵循了其中一个，那么肯定会在其中找到另一个原则的影子，万物相生相息，有一定的共通性。","tags":[{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计原则","slug":"设计原则","permalink":"http://qgxiaojin.com/tags/设计原则/"}]},{"title":"面向对象设计原则：开闭原则（The Open Closed Principle）","date":"2017-03-07T15:23:22.000Z","path":"2017/03/07/面向对象设计原则：开闭原则（The-Open-Closed-Principle）/","text":"什么是开闭原则？ 官方解释：对扩展开放（Open）—对修改关闭（Closed） 通俗解释：在对一个系统模块（类）增加功能的时候，应该基于不修改原来的模块代码的基础上，进行功能、模块拓展。 为什么遵循开闭原则？ 开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则都是实现开闭原则的一种手段。—-百度百科 应用开发的生命周期内，因为需求变化、版本升级和系统维护等原因需要对软件进行维护时，若软件应用系统不遵循开闭原则或不完全遵循开闭原则，可能会给旧代码中引入错误，甚至会使我们不得不对整个模块重构，并且修改之处需要重新进行测试。 当一个软件应用系统是遵循开闭原则来进行设计的，那么这个软件系统是具有高可复用性、可维护性。 复用性体现在：一个模块设计完成后，有新的需求（功能）的时候，随时可以在原来的基础上进行拓展而不影响系统的抽象底层模块。 维护性体现在：对于已完成的模块组件，其抽象底层在增加功能的时候不会被修改，这使得系统具有一定的稳定性和延续性。 如何遵循开闭原则？ 那么在软件设计开发的时候，应当如何遵循开闭原则呢？ 在实际参与项目开发的时候，亘古不变，一直都是由需求驱动的，这便使得我们在设计的时候，需要考虑已有的需求，以及可能会增加、变化的需求，然后将这些所有可能的行为进行“抽象”，作为系统的抽象底层，来构建软件的框架。由预见了可能的扩展，从而是的在需求新增的时候，不需要修改抽象底层，而是继承抽象底层重新派生一个实现类来扩展就好了，由于可从抽象层引出一个或多个新的具体功能实现，改变系统的行为，因此系统是可拓展的。 但是，在软件设计之初就要罗列出系统所有可能的行为，并将这些行为进行抽象加入到抽象底层，这是不可能的，往这个方向去耗费太多时间经历也是不值得的，因此我们应该灵活应用，拥抱变化，在适当的时候进行修改重构。这就不得不提到重构的艺术了，是的，重构也是一门艺术，往后我也会出相关的系列，自己学习的同时分享给大家。","tags":[{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计原则","slug":"设计原则","permalink":"http://qgxiaojin.com/tags/设计原则/"}]},{"title":"面向对象设计原则：依赖倒置原则（The Dependency Inversion Principle）","date":"2017-03-07T15:05:35.000Z","path":"2017/03/07/面向对象设计原则：依赖倒置原则（The-Dependency-Inversion-Principle）/","text":"什么是依赖倒置原则？ 官方解释：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 通俗解释：高层模块指的是抽象层次较高的抽象类、接口，底层模块则一般是指实现高层模块接口的类，抽象是不能够实例化的类、接口，细节是指继承抽象类、实现接口的可实例化类。明白这个后那么官方解释的依赖倒置原则就很容易理解了。 为什么遵循依赖倒置原则？ 相对于细节（可实例化类）的多变性，抽象（接口、抽象类）则要稳定的多，同常定义后除了拓展，在修改某个接口的功能的时候，基本是以修改细节或者拓展一个新的细节来实现的，因此，以抽象搭建起来的系统架构会比以细节为基础搭建的系统架构要稳定得多。 依赖倒置原则的本质上就是面向接口编程（契约式编程），通过抽象（定义好接口、抽象方法）使各个细节（实现模块）相互独立，各自不影响，实现上述的一种松耦合的稳定性系统架构。 抽象想要达到的效果是，通过指定好规范和契约，不去涉及具体操作细节，把具体的操作细节交给实现类（细节）去完成，同样也遵循着开闭原则。 如何遵循依赖倒置原则？在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 依赖实现的方式大致分为三种： 通过构造函数传递依赖的对象。 通过setter方法传递依赖的对象。 通过接口前置条件（输入参数）传递依赖的对象。 简单举例： 12345678910111213141516171819public class Bun &#123; public void cook()&#123; System. out .println(\"包子烹饪中……\" ); &#125;&#125;public class Ming&#123; public void cook(Bun bun)&#123; System. out .println(\"小明着手烹饪\" ); bun.cook(); &#125;&#125;public class ClientTest&#123; public static void main(String[] args)&#123; Ming xiaoming = new Ming(); xiaoming.cook( new Bun()); &#125;&#125; 输出结果： 小明着手烹饪 包子烹饪中…… 那么现在新的需求来了，小明已经学会了烹饪饺子，那么基于上述代码，很明显由于Ming依赖与Bun的具体实现，而不是CookingMartialFood（烹饪食物）的具体抽象，因此需要大肆改造代码才能拓展功能。如下： 123456789101112131415161718192021222324252627282930interface CookingMaterialFood&#123; public void cook();&#125;public class Bun implements CookingMaterialFood&#123; public void cook()&#123; System.out.println( \"包子烹饪中……\" ); &#125;&#125;public class Dumpling implements CookingMaterialFood&#123; public void cook()&#123; System. out .println(\"饺子烹饪中……\" ); &#125;&#125;public class Ming&#123; public void cook(CookingMaterialFood food)&#123; System.out.println( \"小明着手烹饪\" ); food.cook(); &#125;&#125;public class ClientTest&#123; public static void main(String[] args)&#123; Ming xiaoming = new Ming(); xiaoming.cook( new Bun()); xiaoming.cook( new Dumpling()); &#125;&#125; 那么此时的设计很显然是遵循依赖倒置原则的，细节（Ming）依赖与抽象（CookingMaterialFood）实现了小明和食材的松耦合，对于Ming来说，并不关心具体的食材，当新增烹饪的食材时，仅需实现CookingMaterialFood来拓展烹饪类，而无需修改Ming类。","tags":[{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计原则","slug":"设计原则","permalink":"http://qgxiaojin.com/tags/设计原则/"}]},{"title":"面向对象设计原则：单一职责原则（The Single Responsibility Principle）","date":"2017-03-07T14:56:31.000Z","path":"2017/03/07/面向对象设计原则：单一职责原则（The-Single-Responsibility-Principle）/","text":"什么是单一职责原则？ 官方解释：一个类应该只有一种改变的原因 通俗解释：一个类被修改、拓展的时候，应该只能因为一种职责（功能）的扩展，而不应该有第二种职责导致类的修改，一个也不能有另一种职责存在。 为什么遵循单一职责原则？ 降低类的复杂度，一个类负责一种职责，逻辑上也变得直观简单。 使代码变得灵活，提高系统的维护性。 变更的风险降低，有需求就会有变更，单一职责原则可降低变更的影响面。 保持松耦合，提供内聚。 如何使用单一职责原则？ 单一职责原则是设计原则中最简单的，最直观的，但是，往往一些很有经验的开发者在比较负责的项目开发的时候，也经常会犯下错误，一个负责两个或多个职责。因为代码是经常发生变更的，有时候为了快速完成开发，或者代码逻辑并不复杂，改动不大，可能在代码逻辑上不遵循这一原则，或者在方法层次不遵循这一原则，视情况而定，在某些情况下是可行的。但更有甚者，在类层次、包层次不遵循这一原则，导致代码可读性差，影响面增大，脆弱难以维护，这是没有经验的程序员才会干出的事情。 简单举例：现在我在一个开发一个即时聊天工具，现在我想实现发送消息功能，我需要一个SendMessager类。123456public class SendMessager&#123; public boolean sendMessage(String content, String sender, String receiver)&#123; println(sender + \" send message to \" + receiver); return true; &#125;&#125; 这里没什么问题，但是你发现发送内容并没有经过加密，你想要有包含数字的内容被加密后再发送。于是呼1234567891011121314public class SendMessager&#123; public boolean sendMessage(String content, String sender, String receiver)&#123; /** 如果包含数字 */ if(content contains numeric)&#123; content = md5(content); println(sender + \" send message to \" + receiver); return true; &#125; println(sender + \" send message to \" + receiver); return true; &#125;&#125; 或者完全遵循单一原则：1234567891011121314151617public class SendMessager&#123; public boolean sendMessage(String content, String sender, String receiver)&#123; println(sender + \" send message to \" + receiver); return true; &#125;&#125;public class SendMd5Messager&#123; /** 发送经过加密后的消息 */ public boolean sendMessage(String content, String sender, String receiver)&#123; content = md5(content); println(sender + \" send message to \" + receiver); return true; &#125;&#125; 在这样简单的逻辑上看，似乎这三种情况都是可行并且也不怎么影响代码的负责度。但是，当职责分化的时候，或者需求增加的时候，三种设计的影响差别就很明显了。 比如，现在我想增加一种加密方式，用RSA算法来加密，那么第一种实现，将会影响到代码层次上的变更，第二种实现，会影响到方法层次上的变更，第三种，并没有产生什么影响，仅仅是新增一个SendRSAMessager类而已。 因此，我个人认为，三种设计层次，视职责分化的可能性而定，方法层次上的设计是可以被允许的，最好是用第三种方法，遵循单一职责原则。","tags":[{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计原则","slug":"设计原则","permalink":"http://qgxiaojin.com/tags/设计原则/"}]},{"title":"面向对象设计原则：接口隔离原则（The Interface Segregation Principle）","date":"2017-03-07T14:56:31.000Z","path":"2017/03/07/面向对象设计原则：接口隔离原则（The-Interface-Segregation-Principle）/","text":"什么是接口隔离原则？ 官方解释：客户端不应该依赖它不需要的接口，使用户指定的类建立在最小粒度上。 通俗解释：定义接口的时候，在不违背单一职责原则的情况下，接口尽可能建立在最小粒度上，即尽可能细化接口，是接口变得单一。 为什么遵循接口隔离原则？ 接口尽量小时，防止出现接口臃肿，抽象不彻底，代码利用率低的情况。 为用户指定的类提供定制服务，只暴露给用户所需的接口方法，对于不需要的方法则是透明的，使得依赖关系单一，容易管理。 越少的接口暴露则表明类越内聚，对外的交互越单一，变更所产生的风险和成本也越低。 如何遵循接口隔离原则？ 比如，现在我新建了一个球员类YaoMing，假设姚明的主要能力有二分、扣篮、勾手、传球。以及另一个球员类McGrady，假设麦迪的主要能力有二分、三分、扣篮、勾手、背后运球、变向运球、传球。然后我抽象了一个接口 BasketBallAction，如下： 红点代表姚明的能力，蓝点代表麦迪的能力，那么此时很明显，对于YaoMing依赖与BasketBallActionImpl，此时有三个接口是BasketBallActionImpl必须实现但YaoMing又不需要用到的。而对于McGrady依赖与BasketBallActionImpl，此时有一个接口是BasketBallActionImpl必须实现但McGrady又不需要用到的。那么在这样的情况下，BasketBallAction接口的设计就显然违背了接口隔离原则。 可以有另一种设计方案： 红点代表姚明的能力，蓝点代表麦迪的能力，此时抽象出来的接口显得很单一又专注，并不显得臃肿，可扩展性、维护性也有所提高。有人会说这里的ShotAction也有双方各自用不到的接口呀，这里其实我设计另一个完全单一的接口也是可以的，但我想表明的是，此时的ShotAction设计在抽象层次上已经是属于仅负责一种职责：投篮得分，在符合单一职责原则下，接口要适度，不要过度细化。接口只能说是尽可能小，但是过于细化也会造成类过多，变得复杂化。 最后强调一点，单一职责原则与接口隔离原则表面上看起来似乎很相似，其实不然。单一职责注重的是“职责”，是代码功能实现上的隔离，而接口隔离原则注重的是对接口的隔离，针对底层抽象层次上接口的的隔离。","tags":[{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计原则","slug":"设计原则","permalink":"http://qgxiaojin.com/tags/设计原则/"}]},{"title":"面向对象设计原则：里氏替换原则(Liskov Substitution principle)","date":"2017-03-07T14:49:03.000Z","path":"2017/03/07/面向对象设计原则：里氏替换原则-Liskov-Substitution-principle/","text":"什么是里氏替换原则？ 官方解释：派生类必须是能够替代基类的 通俗解释：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 为什么遵循里氏替换原则？ 提高代码利用率，减少代码工作量。 增强应用的健壮性，保持良好兼容性。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 如何遵循里氏替换原则？ 里氏替换原则有四层含义： 子类可以实现父类的抽象方法，但不能修改父类原有的方法。 子类可以具有自己的功能方法。 实现、重载父类的方法时，方法的输入（前置条件）可以放大 实现、重载父类的方法时，方法的输入（后置条件）必须缩小 第一层含义，字面意思，子类可以实现父类中被定义为抽象、完全抽象的方法，但是不应该修改父类原有的方法，即使原有功能增强，可以在实现原有方法的同时，增加自己需要的功能代码，不过此时就要遵循第三层、第四层含义了，此时输入参数可以比原有方法更宽松，而输出结果则起码要保证和原来一样或者更严格，否则，则建议遵循第二层含义，实现自己的功能方法，而不去修改父类原有的方法。","tags":[{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计原则","slug":"设计原则","permalink":"http://qgxiaojin.com/tags/设计原则/"}]},{"title":"面向对象设计--译自Robert C. Martin","date":"2017-02-27T11:27:01.000Z","path":"2017/02/27/面向对象设计原则/","text":"原文地址http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod 作者：Robert C Martin(uncle bob) 面向对象设计 什么是面向对象设计？这是怎么一回事？它有什么好处？它的代价是什么？在这个几乎所有开发者都在使用某种面向对象语言的时代问这些问题似乎是很愚蠢的。但是这些问题是很重要的，因为，在我看来，我们大多数人使用这些语言的时候不知道为什么，不知道如何从这些语言中得到最大的价值。所有在我们这个行业的革命，有两个很成功的例子一直深入人心，令我们认为理所当然的存在。结构化编程和面向对象编程。如今所有主流的编程语言受到这两门学问的深刻影响。是的，已经很难写出不具备结构化程序设计和面向对象编程的外观的程序。我们的主流语言没有goto语句，因此似乎服从结构化编程有名的禁制。大多数主流语言是基于类的并且在不在类内部的时候不支持函数方法和变量，因此似乎符合面向对象编程最明显的标志。 这些语言编写的程序看起来似乎是结构化和面向对象的，但这看起来是可决定的。往往今天的程序员没有意识到这些原则是他们的编程语言围绕的学问（结构化和面向对象）的基础。在另一个博客中，我将讨论结构化程序设计的原则。在这个博客，我想谈谈面向对象编程的原则。 在1995年3月，在comp.object，我写了一篇文章，是我用过很多次的一组OOD原则的第一点。你可以从我的PPP book中看到记载，另外在 theobjectmentor website还有很多文章，包括我们熟知的summary。 这些原则揭露OOD的依赖管理方面的思想，而不是在构思和建模方面的思想。这不是说OO对于问题空间的构思方面是一件很糟糕的工具，也并不是说它不是创建模型的好场所。可以肯定，很多人在OO的这些方面获得价值。但是，这些原则集中在紧密的依赖管理关系中。 依赖关系管理是一个我们大多数人要面对的问题，每当我们的屏幕出现一批令人讨厌的、纠结的遗留代码，我们正在经历依赖关系管理不佳的后果。依赖关系管理不佳会导致代码是很难改变的，脆弱的，不可复用的。的确，我就谈谈PPP book中几本不同设计味道的书，全部和依赖关系管理有联系。另一方面，当依赖关系被良好管理后，代码是灵活的，健壮的，可复用的。所以依赖关系管理，还有这些原则，是软件开发者梦寐以求的基本工具。前五个原则是类设计原则，如下： 缩写 全称 含义 SRR 单一职责原则（The Single Responsibility Principle） 该有且只有一个发生变化的原因 OCP 开闭原则（The Open Closed Principle） 你应该能够拓展类的行为，而不是修改它 LSP 里氏替换原则（The Liskov Substitution Principle） 派生类必须是能够替代基类的 ISP 接口隔离原则（The Interface Segregation Principle） 使用户指定的类建立M在最小粒度上 DIP 依赖倒置原则（The Dependency Inversion Principle） 依赖于抽象，不依赖于具体 下面的六个原则是关于包的，这里的包是一个可交付的二进制文件，像.jar或Dll，而不是java中的包或者c++中的域名空间。前三个原则是关于包内聚的，它告诉我们应该往包里塞什么: 缩写 全称 含义 REP 重用-发布等价原则（Release-Reuse Equivalency Principle） 复用的粒度就是发布的粒度 CCP 共同封闭原则（The Common Closure Principle） 一起改变的类一起打包 CRP 共同重用原则（The Common Reuse Principle） 一起使用的类一起打包 最后三个原则是关于包之间的耦合的，并来谈谈评估系统的包结构的指标。 缩写 全称 含义 ADP 无循环依赖原则（The Acyclic Dependencies Principle） 包的依赖关系图必须没有环 SDP 稳定依赖原则（ The Stable Dependencies Principle） 依赖在稳定的方向上（更稳定的包） SAP 稳定抽象等价原则（The Stable Abstractions Principle） 包的稳定性随着抽象程序增加而增加","tags":[{"name":"技术","slug":"技术","permalink":"http://qgxiaojin.com/tags/技术/"},{"name":"设计原则","slug":"设计原则","permalink":"http://qgxiaojin.com/tags/设计原则/"}]}]